{
  "version": 3,
  "sources": ["../../@apollo/src/react/context/ApolloConsumer.tsx", "../../@apollo/src/react/context/ApolloContext.ts", "../../@apollo/src/react/context/ApolloProvider.tsx", "../../@apollo/src/react/hooks/useApolloClient.ts", "../../@apollo/src/react/hooks/useLazyQuery.ts", "../../@apollo/src/react/hooks/useQuery.ts", "../../@apollo/src/react/hooks/useSyncExternalStore.ts", "../../@apollo/src/react/parser/index.ts", "../../@apollo/src/react/hooks/useMutation.ts", "../../@apollo/src/react/hooks/useSubscription.ts", "../../@apollo/src/react/hooks/useReactiveVar.ts", "../../@apollo/src/react/hooks/useFragment.ts", "../../@apollo/src/react/hooks/useSuspenseQuery.ts", "../../@apollo/src/react/hooks/internal/useDeepMemo.ts", "../../@apollo/src/react/hooks/internal/useIsomorphicLayoutEffect.ts", "../../@apollo/src/react/hooks/internal/__use.ts", "../../@apollo/src/react/cache/QueryReference.ts", "../../@apollo/src/react/cache/SuspenseCache.ts", "../../@apollo/src/react/cache/getSuspenseCache.ts", "../../@apollo/src/react/hooks/constants.ts", "../../@apollo/src/react/hooks/useBackgroundQuery.ts", "../../@apollo/src/react/hooks/useReadQuery.ts"],
  "sourcesContent": ["import { invariant } from \"../../utilities/globals/index.js\";\n\nimport * as React from \"react\";\n\nimport type { ApolloClient } from \"../../core/index.js\";\nimport { getApolloContext } from \"./ApolloContext.js\";\n\nexport interface ApolloConsumerProps {\n  children: (client: ApolloClient<object>) => React.ReactChild | null;\n}\n\nexport const ApolloConsumer: React.FC<ApolloConsumerProps> = (props) => {\n  const ApolloContext = getApolloContext();\n  return (\n    <ApolloContext.Consumer>\n      {(context: any) => {\n        invariant(\n          context && context.client,\n          'Could not find \"client\" in the context of ApolloConsumer. ' +\n            \"Wrap the root component in an <ApolloProvider>.\"\n        );\n        return props.children(context.client);\n      }}\n    </ApolloContext.Consumer>\n  );\n};\n", "import * as React from \"react\";\nimport type { ApolloClient } from \"../../core/index.js\";\nimport { canUseSymbol } from \"../../utilities/index.js\";\nimport type { RenderPromises } from \"../ssr/index.js\";\nimport { invariant } from \"../../utilities/globals/index.js\";\n\nexport interface ApolloContextValue {\n  client?: ApolloClient<object>;\n  renderPromises?: RenderPromises;\n}\n\n// To make sure Apollo Client doesn't create more than one React context\n// (which can lead to problems like having an Apollo Client instance added\n// in one context, then attempting to retrieve it from another different\n// context), a single Apollo context is created and tracked in global state.\nconst contextKey = canUseSymbol\n  ? Symbol.for(\"__APOLLO_CONTEXT__\")\n  : \"__APOLLO_CONTEXT__\";\n\nexport function getApolloContext(): React.Context<ApolloContextValue> {\n  invariant(\n    \"createContext\" in React,\n    \"Invoking `getApolloContext` in an environment where `React.createContext` is not available.\\n\" +\n      \"The Apollo Client functionality you are trying to use is only available in React Client Components.\\n\" +\n      'Please make sure to add \"use client\" at the top of your file.\\n' +\n      // TODO: change to React documentation once React documentation contains information about Client Components\n      \"For more information, see https://nextjs.org/docs/getting-started/react-essentials#client-components\"\n  );\n\n  let context = (React.createContext as any)[\n    contextKey\n  ] as React.Context<ApolloContextValue>;\n  if (!context) {\n    Object.defineProperty(React.createContext, contextKey, {\n      value: (context = React.createContext<ApolloContextValue>({})),\n      enumerable: false,\n      writable: false,\n      configurable: true,\n    });\n    context.displayName = \"ApolloContext\";\n  }\n  return context;\n}\n\n/**\n * @deprecated This function has no \"resetting\" effect since Apollo Client 3.4.12,\n * and will be removed in the next major version of Apollo Client.\n * If you want to get the Apollo Context, use `getApolloContext` instead.\n */\nexport const resetApolloContext = getApolloContext;\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\nimport * as React from \"react\";\n\nimport type { ApolloClient } from \"../../core/index.js\";\nimport { getApolloContext } from \"./ApolloContext.js\";\n\nexport interface ApolloProviderProps<TCache> {\n  client: ApolloClient<TCache>;\n  children: React.ReactNode | React.ReactNode[] | null;\n}\n\nexport const ApolloProvider: React.FC<ApolloProviderProps<any>> = ({\n  client,\n  children,\n}) => {\n  const ApolloContext = getApolloContext();\n  const parentContext = React.useContext(ApolloContext);\n\n  const context = React.useMemo(() => {\n    return {\n      ...parentContext,\n      client: client || parentContext.client,\n    };\n  }, [parentContext, client]);\n\n  invariant(\n    context.client,\n    \"ApolloProvider was not passed a client instance. Make \" +\n      'sure you pass in your client via the \"client\" prop.'\n  );\n\n  return (\n    <ApolloContext.Provider value={context}>{children}</ApolloContext.Provider>\n  );\n};\n", "import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"react\";\nimport type { ApolloClient } from \"../../core/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\n\nexport function useApolloClient(\n  override?: ApolloClient<object>\n): ApolloClient<object> {\n  const context = React.useContext(getApolloContext());\n  const client = override || context.client;\n  invariant(\n    !!client,\n    'Could not find \"client\" in the context or passed in as an option. ' +\n      \"Wrap the root component in an <ApolloProvider>, or pass an ApolloClient \" +\n      \"instance in via options.\"\n  );\n\n  return client;\n}\n", "import type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport * as React from \"react\";\n\nimport type { OperationVariables } from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport type {\n  LazyQueryHookExecOptions,\n  LazyQueryHookOptions,\n  LazyQueryResultTuple,\n  NoInfer,\n  QueryResult,\n} from \"../types/types.js\";\nimport { useInternalState } from \"./useQuery.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\n  \"refetch\",\n  \"reobserve\",\n  \"fetchMore\",\n  \"updateQuery\",\n  \"startPolling\",\n  \"subscribeToMore\",\n] as const;\n\nexport function useLazyQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LazyQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): LazyQueryResultTuple<TData, TVariables> {\n  const execOptionsRef =\n    React.useRef<Partial<LazyQueryHookExecOptions<TData, TVariables>>>();\n  const optionsRef = React.useRef<LazyQueryHookOptions<TData, TVariables>>();\n  const queryRef = React.useRef<\n    DocumentNode | TypedDocumentNode<TData, TVariables>\n  >();\n  const merged = mergeOptions(options, execOptionsRef.current || {});\n  const document = merged?.query ?? query;\n\n  // Use refs to track options and the used query to ensure the `execute`\n  // function remains referentially stable between renders.\n  optionsRef.current = merged;\n  queryRef.current = document;\n\n  const internalState = useInternalState<TData, TVariables>(\n    useApolloClient(options && options.client),\n    document\n  );\n\n  const useQueryResult = internalState.useQuery({\n    ...merged,\n    skip: !execOptionsRef.current,\n  });\n\n  const initialFetchPolicy =\n    useQueryResult.observable.options.initialFetchPolicy ||\n    internalState.getDefaultFetchPolicy();\n\n  const result: QueryResult<TData, TVariables> = Object.assign(useQueryResult, {\n    called: !!execOptionsRef.current,\n  });\n\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = React.useMemo(() => {\n    const eagerMethods: Record<string, any> = {};\n    for (const key of EAGER_METHODS) {\n      const method = result[key];\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          // Only the first time populating execOptionsRef.current matters here.\n          internalState.forceUpdateState();\n        }\n        return method.apply(this, arguments);\n      };\n    }\n\n    return eagerMethods;\n  }, []);\n\n  Object.assign(result, eagerMethods);\n\n  const execute = React.useCallback<LazyQueryResultTuple<TData, TVariables>[0]>(\n    (executeOptions) => {\n      execOptionsRef.current = executeOptions\n        ? {\n            ...executeOptions,\n            fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy,\n          }\n        : {\n            fetchPolicy: initialFetchPolicy,\n          };\n\n      const options = mergeOptions(optionsRef.current, {\n        query: queryRef.current,\n        ...execOptionsRef.current,\n      });\n\n      const promise = internalState\n        .executeQuery({ ...options, skip: false })\n        .then((queryResult) => Object.assign(queryResult, eagerMethods));\n\n      // Because the return value of `useLazyQuery` is usually floated, we need\n      // to catch the promise to prevent unhandled rejections.\n      promise.catch(() => {});\n\n      return promise;\n    },\n    []\n  );\n\n  return [execute, result];\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\nimport * as React from \"react\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from \"@wry/equality\";\n\nimport type {\n  OperationVariables,\n  WatchQueryFetchPolicy,\n} from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport type { ApolloContextValue } from \"../context/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport type {\n  ApolloClient,\n  ApolloQueryResult,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport type {\n  QueryHookOptions,\n  QueryResult,\n  ObservableQueryFields,\n  NoInfer,\n} from \"../types/types.js\";\n\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport {\n  canUseWeakMap,\n  compact,\n  isNonEmptyArray,\n  maybeDeepFreeze,\n} from \"../../utilities/index.js\";\n\nconst {\n  prototype: { hasOwnProperty },\n} = Object;\n\nexport function useQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<\n    NoInfer<TData>,\n    NoInfer<TVariables>\n  > = Object.create(null)\n): QueryResult<TData, TVariables> {\n  return useInternalState(useApolloClient(options.client), query).useQuery(\n    options\n  );\n}\n\nexport function useInternalState<TData, TVariables extends OperationVariables>(\n  client: ApolloClient<any>,\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>\n): InternalState<TData, TVariables> {\n  const stateRef = React.useRef<InternalState<TData, TVariables>>();\n  if (\n    !stateRef.current ||\n    client !== stateRef.current.client ||\n    query !== stateRef.current.query\n  ) {\n    stateRef.current = new InternalState(client, query, stateRef.current);\n  }\n  const state = stateRef.current;\n\n  // By default, InternalState.prototype.forceUpdate is an empty function, but\n  // we replace it here (before anyone has had a chance to see this state yet)\n  // with a function that unconditionally forces an update, using the latest\n  // setTick function. Updating this state by calling state.forceUpdate is the\n  // only way we trigger React component updates (no other useState calls within\n  // the InternalState class).\n  state.forceUpdateState = React.useReducer((tick) => tick + 1, 0)[1];\n\n  return state;\n}\n\nclass InternalState<TData, TVariables extends OperationVariables> {\n  constructor(\n    public readonly client: ReturnType<typeof useApolloClient>,\n    public readonly query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    previous?: InternalState<TData, TVariables>\n  ) {\n    verifyDocumentType(query, DocumentType.Query);\n\n    // Reuse previousData from previous InternalState (if any) to provide\n    // continuity of previousData even if/when the query or client changes.\n    const previousResult = previous && previous.result;\n    const previousData = previousResult && previousResult.data;\n    if (previousData) {\n      this.previousData = previousData;\n    }\n  }\n\n  /**\n   * Forces an update using local component state.\n   * As this is not batched with `useSyncExternalStore` updates,\n   * this is only used as a fallback if the `useSyncExternalStore` \"force update\"\n   * method is not registered at the moment.\n   * See https://github.com/facebook/react/issues/25191\n   *  */\n  forceUpdateState() {\n    // Replaced (in useInternalState) with a method that triggers an update.\n    invariant.warn(\n      \"Calling default no-op implementation of InternalState#forceUpdate\"\n    );\n  }\n\n  /**\n   * Will be overwritten by the `useSyncExternalStore` \"force update\" method\n   * whenever it is available and reset to `forceUpdateState` when it isn't.\n   */\n  forceUpdate = () => this.forceUpdateState();\n\n  executeQuery(\n    options: QueryHookOptions<TData, TVariables> & {\n      query?: DocumentNode;\n    }\n  ) {\n    if (options.query) {\n      Object.assign(this, { query: options.query });\n    }\n\n    this.watchQueryOptions = this.createWatchQueryOptions(\n      (this.queryHookOptions = options)\n    );\n\n    const concast = this.observable.reobserveAsConcast(\n      this.getObsQueryOptions()\n    );\n\n    // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n    // but save the current data as this.previousData, just like setResult\n    // usually does.\n    this.previousData = this.result?.data || this.previousData;\n    this.result = void 0;\n    this.forceUpdate();\n\n    return new Promise<QueryResult<TData, TVariables>>((resolve) => {\n      let result: ApolloQueryResult<TData>;\n\n      // Subscribe to the concast independently of the ObservableQuery in case\n      // the component gets unmounted before the promise resolves. This prevents\n      // the concast from terminating early and resolving with `undefined` when\n      // there are no more subscribers for the concast.\n      concast.subscribe({\n        next: (value) => {\n          result = value;\n        },\n        error: () => {\n          resolve(this.toQueryResult(this.observable.getCurrentResult()));\n        },\n        complete: () => {\n          resolve(this.toQueryResult(result));\n        },\n      });\n    });\n  }\n\n  // Methods beginning with use- should be called according to the standard\n  // rules of React hooks: only at the top level of the calling function, and\n  // without any dynamic conditional logic.\n  useQuery(options: QueryHookOptions<TData, TVariables>) {\n    // The renderPromises field gets initialized here in the useQuery method, at\n    // the beginning of everything (for a given component rendering, at least),\n    // so we can safely use this.renderPromises in other/later InternalState\n    // methods without worrying it might be uninitialized. Even after\n    // initialization, this.renderPromises is usually undefined (unless SSR is\n    // happening), but that's fine as long as it has been initialized that way,\n    // rather than left uninitialized.\n    this.renderPromises = React.useContext(getApolloContext()).renderPromises;\n\n    this.useOptions(options);\n\n    const obsQuery = this.useObservableQuery();\n\n    const result = useSyncExternalStore(\n      React.useCallback(\n        (handleStoreChange) => {\n          if (this.renderPromises) {\n            return () => {};\n          }\n\n          this.forceUpdate = handleStoreChange;\n\n          const onNext = () => {\n            const previousResult = this.result;\n            // We use `getCurrentResult()` instead of the onNext argument because\n            // the values differ slightly. Specifically, loading results will have\n            // an empty object for data instead of `undefined` for some reason.\n            const result = obsQuery.getCurrentResult();\n            // Make sure we're not attempting to re-render similar results\n            if (\n              previousResult &&\n              previousResult.loading === result.loading &&\n              previousResult.networkStatus === result.networkStatus &&\n              equal(previousResult.data, result.data)\n            ) {\n              return;\n            }\n\n            this.setResult(result);\n          };\n\n          const onError = (error: Error) => {\n            subscription.unsubscribe();\n            subscription = obsQuery.resubscribeAfterError(onNext, onError);\n\n            if (!hasOwnProperty.call(error, \"graphQLErrors\")) {\n              // The error is not a GraphQL error\n              throw error;\n            }\n\n            const previousResult = this.result;\n            if (\n              !previousResult ||\n              (previousResult && previousResult.loading) ||\n              !equal(error, previousResult.error)\n            ) {\n              this.setResult({\n                data: (previousResult && previousResult.data) as TData,\n                error: error as ApolloError,\n                loading: false,\n                networkStatus: NetworkStatus.error,\n              });\n            }\n          };\n\n          let subscription = obsQuery.subscribe(onNext, onError);\n\n          // Do the \"unsubscribe\" with a short delay.\n          // This way, an existing subscription can be reused without an additional\n          // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n          // happen in very fast succession.\n          return () => {\n            setTimeout(() => subscription.unsubscribe());\n            this.forceUpdate = () => this.forceUpdateState();\n          };\n        },\n        [\n          // We memoize the subscribe function using useCallback and the following\n          // dependency keys, because the subscribe function reference is all that\n          // useSyncExternalStore uses internally as a dependency key for the\n          // useEffect ultimately responsible for the subscription, so we are\n          // effectively passing this dependency array to that useEffect buried\n          // inside useSyncExternalStore, as desired.\n          obsQuery,\n          this.renderPromises,\n          this.client.disableNetworkFetches,\n        ]\n      ),\n\n      () => this.getCurrentResult(),\n      () => this.getCurrentResult()\n    );\n\n    // TODO Remove this method when we remove support for options.partialRefetch.\n    this.unsafeHandlePartialRefetch(result);\n\n    return this.toQueryResult(result);\n  }\n\n  // These members (except for renderPromises) are all populated by the\n  // useOptions method, which is called unconditionally at the beginning of the\n  // useQuery method, so we can safely use these members in other/later methods\n  // without worrying they might be uninitialized.\n  private renderPromises: ApolloContextValue[\"renderPromises\"];\n  private queryHookOptions: QueryHookOptions<TData, TVariables>;\n  private watchQueryOptions: WatchQueryOptions<TVariables, TData>;\n\n  private useOptions(options: QueryHookOptions<TData, TVariables>) {\n    const watchQueryOptions = this.createWatchQueryOptions(\n      (this.queryHookOptions = options)\n    );\n\n    // Update this.watchQueryOptions, but only when they have changed, which\n    // allows us to depend on the referential stability of\n    // this.watchQueryOptions elsewhere.\n    const currentWatchQueryOptions = this.watchQueryOptions;\n\n    if (!equal(watchQueryOptions, currentWatchQueryOptions)) {\n      this.watchQueryOptions = watchQueryOptions;\n\n      if (currentWatchQueryOptions && this.observable) {\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        this.observable.reobserve(this.getObsQueryOptions());\n\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        this.previousData = this.result?.data || this.previousData;\n        this.result = void 0;\n      }\n    }\n\n    // Make sure state.onCompleted and state.onError always reflect the latest\n    // options.onCompleted and options.onError callbacks provided to useQuery,\n    // since those functions are often recreated every time useQuery is called.\n    // Like the forceUpdate method, the versions of these methods inherited from\n    // InternalState.prototype are empty no-ops, but we can override them on the\n    // base state object (without modifying the prototype).\n    this.onCompleted =\n      options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n\n    if (\n      (this.renderPromises || this.client.disableNetworkFetches) &&\n      this.queryHookOptions.ssr === false &&\n      !this.queryHookOptions.skip\n    ) {\n      // If SSR has been explicitly disabled, and this function has been called\n      // on the server side, return the default loading state.\n      this.result = this.ssrDisabledResult;\n    } else if (\n      this.queryHookOptions.skip ||\n      this.watchQueryOptions.fetchPolicy === \"standby\"\n    ) {\n      // When skipping a query (ie. we're not querying for data but still want to\n      // render children), make sure the `data` is cleared out and `loading` is\n      // set to `false` (since we aren't loading anything).\n      //\n      // NOTE: We no longer think this is the correct behavior. Skipping should\n      // not automatically set `data` to `undefined`, but instead leave the\n      // previous data in place. In other words, skipping should not mandate that\n      // previously received data is all of a sudden removed. Unfortunately,\n      // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n      // to address this.\n      this.result = this.skipStandbyResult;\n    } else if (\n      this.result === this.ssrDisabledResult ||\n      this.result === this.skipStandbyResult\n    ) {\n      this.result = void 0;\n    }\n  }\n\n  private getObsQueryOptions(): WatchQueryOptions<TVariables, TData> {\n    const toMerge: Array<Partial<WatchQueryOptions<TVariables, TData>>> = [];\n\n    const globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n\n    if (this.queryHookOptions.defaultOptions) {\n      toMerge.push(this.queryHookOptions.defaultOptions);\n    }\n\n    // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n    toMerge.push(\n      compact(\n        this.observable && this.observable.options,\n        this.watchQueryOptions\n      )\n    );\n\n    return toMerge.reduce(mergeOptions) as WatchQueryOptions<TVariables, TData>;\n  }\n\n  private ssrDisabledResult = maybeDeepFreeze({\n    loading: true,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.loading,\n  });\n\n  private skipStandbyResult = maybeDeepFreeze({\n    loading: false,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.ready,\n  });\n\n  // A function to massage options before passing them to ObservableQuery.\n  private createWatchQueryOptions({\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    defaultOptions,\n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    ...otherOptions\n  }: QueryHookOptions<TData, TVariables> = {}): WatchQueryOptions<\n    TVariables,\n    TData\n  > {\n    // This Object.assign is safe because otherOptions is a fresh ...rest object\n    // that did not exist until just now, so modifications are still allowed.\n    const watchQueryOptions: WatchQueryOptions<TVariables, TData> =\n      Object.assign(otherOptions, { query: this.query });\n\n    if (\n      this.renderPromises &&\n      (watchQueryOptions.fetchPolicy === \"network-only\" ||\n        watchQueryOptions.fetchPolicy === \"cache-and-network\")\n    ) {\n      // this behavior was added to react-apollo without explanation in this PR\n      // https://github.com/apollographql/react-apollo/pull/1579\n      watchQueryOptions.fetchPolicy = \"cache-first\";\n    }\n\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {} as TVariables;\n    }\n\n    if (skip) {\n      const {\n        fetchPolicy = this.getDefaultFetchPolicy(),\n        initialFetchPolicy = fetchPolicy,\n      } = watchQueryOptions;\n\n      // When skipping, we set watchQueryOptions.fetchPolicy initially to\n      // \"standby\", but we also need/want to preserve the initial non-standby\n      // fetchPolicy that would have been used if not skipping.\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy,\n        fetchPolicy: \"standby\",\n      });\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy =\n        this.observable?.options.initialFetchPolicy ||\n        this.getDefaultFetchPolicy();\n    }\n\n    return watchQueryOptions;\n  }\n\n  getDefaultFetchPolicy(): WatchQueryFetchPolicy {\n    return (\n      this.queryHookOptions.defaultOptions?.fetchPolicy ||\n      this.client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\"\n    );\n  }\n\n  // Defining these methods as no-ops on the prototype allows us to call\n  // state.onCompleted and/or state.onError without worrying about whether a\n  // callback was provided.\n  private onCompleted(data: TData) {}\n  private onError(error: ApolloError) {}\n\n  private observable: ObservableQuery<TData, TVariables>;\n  private obsQueryFields: Omit<\n    ObservableQueryFields<TData, TVariables>,\n    \"variables\"\n  >;\n\n  private useObservableQuery() {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    const obsQuery = (this.observable =\n      (this.renderPromises &&\n        this.renderPromises.getSSRObservable(this.watchQueryOptions)) ||\n      this.observable || // Reuse this.observable if possible (and not SSR)\n      this.client.watchQuery(this.getObsQueryOptions()));\n\n    this.obsQueryFields = React.useMemo(\n      () => ({\n        refetch: obsQuery.refetch.bind(obsQuery),\n        reobserve: obsQuery.reobserve.bind(obsQuery),\n        fetchMore: obsQuery.fetchMore.bind(obsQuery),\n        updateQuery: obsQuery.updateQuery.bind(obsQuery),\n        startPolling: obsQuery.startPolling.bind(obsQuery),\n        stopPolling: obsQuery.stopPolling.bind(obsQuery),\n        subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n      }),\n      [obsQuery]\n    );\n\n    const ssrAllowed = !(\n      this.queryHookOptions.ssr === false || this.queryHookOptions.skip\n    );\n\n    if (this.renderPromises && ssrAllowed) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n\n      if (obsQuery.getCurrentResult().loading) {\n        // TODO: This is a legacy API which could probably be cleaned up\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n\n    return obsQuery;\n  }\n\n  // These members are populated by getCurrentResult and setResult, and it's\n  // okay/normal for them to be initially undefined.\n  private result: undefined | ApolloQueryResult<TData>;\n  private previousData: undefined | TData;\n\n  private setResult(nextResult: ApolloQueryResult<TData>) {\n    const previousResult = this.result;\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n    this.result = nextResult;\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult, previousResult);\n  }\n\n  private handleErrorOrCompleted(\n    result: ApolloQueryResult<TData>,\n    previousResult?: ApolloQueryResult<TData>\n  ) {\n    if (!result.loading) {\n      const error = this.toApolloError(result);\n\n      // wait a tick in case we are in the middle of rendering a component\n      Promise.resolve()\n        .then(() => {\n          if (error) {\n            this.onError(error);\n          } else if (\n            result.data &&\n            previousResult?.networkStatus !== result.networkStatus &&\n            result.networkStatus === NetworkStatus.ready\n          ) {\n            this.onCompleted(result.data);\n          }\n        })\n        .catch((error) => {\n          invariant.warn(error);\n        });\n    }\n  }\n\n  private toApolloError(\n    result: ApolloQueryResult<TData>\n  ): ApolloError | undefined {\n    return isNonEmptyArray(result.errors)\n      ? new ApolloError({ graphQLErrors: result.errors })\n      : result.error;\n  }\n\n  private getCurrentResult(): ApolloQueryResult<TData> {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!this.result) {\n      this.handleErrorOrCompleted(\n        (this.result = this.observable.getCurrentResult())\n      );\n    }\n    return this.result;\n  }\n\n  // This cache allows the referential stability of this.result (as returned by\n  // getCurrentResult) to translate into referential stability of the resulting\n  // QueryResult object returned by toQueryResult.\n  private toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)<\n    ApolloQueryResult<TData>,\n    QueryResult<TData, TVariables>\n  >();\n\n  toQueryResult(\n    result: ApolloQueryResult<TData>\n  ): QueryResult<TData, TVariables> {\n    let queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n\n    const { data, partial, ...resultWithoutPartial } = result;\n    this.toQueryResultCache.set(\n      result,\n      (queryResult = {\n        data, // Ensure always defined, even if result.data is missing.\n        ...resultWithoutPartial,\n        ...this.obsQueryFields,\n        client: this.client,\n        observable: this.observable,\n        variables: this.observable.variables,\n        called: !this.queryHookOptions.skip,\n        previousData: this.previousData,\n      })\n    );\n\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      // TODO: Is it possible for both result.error and result.errors to be\n      // defined here?\n      queryResult.error = new ApolloError({ graphQLErrors: result.errors });\n    }\n\n    return queryResult;\n  }\n\n  private unsafeHandlePartialRefetch(result: ApolloQueryResult<TData>) {\n    // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      result.partial &&\n      this.queryHookOptions.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      this.observable.options.fetchPolicy !== \"cache-only\"\n    ) {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      });\n      this.observable.refetch();\n    }\n  }\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"react\";\n\nimport { canUseLayoutEffect } from \"../../utilities/index.js\";\n\nlet didWarnUncachedGetSnapshot = false;\n\ntype RealUseSESHookType =\n  // This import depends only on the @types/use-sync-external-store package, not\n  // the actual use-sync-external-store package, which is not installed. It\n  // might be nice to get this type from React 18, but it still needs to work\n  // when only React 17 or earlier is installed.\n  typeof import(\"use-sync-external-store\").useSyncExternalStore;\n\n// Prevent webpack from complaining about our feature detection of the\n// useSyncExternalStore property of the React namespace, which is expected not\n// to exist when using React 17 and earlier, and that's fine.\nconst uSESKey = \"useSyncExternalStore\" as keyof typeof React;\nconst realHook = React[uSESKey] as RealUseSESHookType | undefined;\n\n// Adapted from https://www.npmjs.com/package/use-sync-external-store, with\n// Apollo Client deviations called out by \"// DEVIATION ...\" comments.\n\n// When/if React.useSyncExternalStore is defined, delegate fully to it.\nexport const useSyncExternalStore: RealUseSESHookType =\n  realHook ||\n  ((subscribe, getSnapshot, getServerSnapshot) => {\n    // Read the current snapshot from the store on every render. Again, this\n    // breaks the rules of React, and only works here because of specific\n    // implementation details, most importantly that updates are\n    // always synchronous.\n    const value = getSnapshot();\n    if (\n      // DEVIATION: Using __DEV__\n      __DEV__ &&\n      !didWarnUncachedGetSnapshot &&\n      // DEVIATION: Not using Object.is because we know our snapshots will never\n      // be exotic primitive values like NaN, which is !== itself.\n      value !== getSnapshot()\n    ) {\n      didWarnUncachedGetSnapshot = true;\n      // DEVIATION: Using invariant.error instead of console.error directly.\n      invariant.error(\n        \"The result of getSnapshot should be cached to avoid an infinite loop\"\n      );\n    }\n\n    // Because updates are synchronous, we don't queue them. Instead we force a\n    // re-render whenever the subscribed state changes by updating an some\n    // arbitrary useState hook. Then, during render, we call getSnapshot to read\n    // the current value.\n    //\n    // Because we don't actually use the state returned by the useState hook, we\n    // can save a bit of memory by storing other stuff in that slot.\n    //\n    // To implement the early bailout, we need to track some things on a mutable\n    // object. Usually, we would put that in a useRef hook, but we can stash it in\n    // our useState hook instead.\n    //\n    // To force a re-render, we call forceUpdate({inst}). That works because the\n    // new object always fails an equality check.\n    const [{ inst }, forceUpdate] = React.useState({\n      inst: { value, getSnapshot },\n    });\n\n    // Track the latest getSnapshot function with a ref. This needs to be updated\n    // in the layout phase so we can access it during the tearing check that\n    // happens on subscribe.\n    if (canUseLayoutEffect) {\n      // DEVIATION: We avoid calling useLayoutEffect when !canUseLayoutEffect,\n      // which may seem like a conditional hook, but this code ends up behaving\n      // unconditionally (one way or the other) because canUseLayoutEffect is\n      // constant.\n      React.useLayoutEffect(() => {\n        Object.assign(inst, { value, getSnapshot });\n        // Whenever getSnapshot or subscribe changes, we need to check in the\n        // commit phase if there was an interleaved mutation. In concurrent mode\n        // this can happen all the time, but even in synchronous mode, an earlier\n        // effect may have mutated the store.\n        if (checkIfSnapshotChanged(inst)) {\n          // Force a re-render.\n          forceUpdate({ inst });\n        }\n      }, [subscribe, value, getSnapshot]);\n    } else {\n      Object.assign(inst, { value, getSnapshot });\n    }\n\n    React.useEffect(() => {\n      // Check for changes right before subscribing. Subsequent changes will be\n      // detected in the subscription handler.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({ inst });\n      }\n\n      // Subscribe to the store and return a clean-up function.\n      return subscribe(function handleStoreChange() {\n        // TODO: Because there is no cross-renderer API for batching updates, it's\n        // up to the consumer of this library to wrap their subscription event\n        // with unstable_batchedUpdates. Should we try to detect when this isn't\n        // the case and print a warning in development?\n\n        // The store changed. Check if the snapshot changed since the last time we\n        // read from the store.\n        if (checkIfSnapshotChanged(inst)) {\n          // Force a re-render.\n          forceUpdate({ inst });\n        }\n      });\n    }, [subscribe]);\n\n    return value;\n  });\n\nfunction checkIfSnapshotChanged<Snapshot>({\n  value,\n  getSnapshot,\n}: {\n  value: Snapshot;\n  getSnapshot: () => Snapshot;\n}): boolean {\n  try {\n    return value !== getSnapshot();\n  } catch {\n    return true;\n  }\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\nimport type {\n  DocumentNode,\n  DefinitionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode,\n} from \"graphql\";\n\nexport enum DocumentType {\n  Query,\n  Mutation,\n  Subscription,\n}\n\nexport interface IDocumentDefinition {\n  type: DocumentType;\n  name: string;\n  variables: ReadonlyArray<VariableDefinitionNode>;\n}\n\nconst cache = new Map();\n\nexport function operationName(type: DocumentType) {\n  let name;\n  switch (type) {\n    case DocumentType.Query:\n      name = \"Query\";\n      break;\n    case DocumentType.Mutation:\n      name = \"Mutation\";\n      break;\n    case DocumentType.Subscription:\n      name = \"Subscription\";\n      break;\n  }\n  return name;\n}\n\n// This parser is mostly used to safety check incoming documents.\nexport function parser(document: DocumentNode): IDocumentDefinition {\n  const cached = cache.get(document);\n  if (cached) return cached;\n\n  let variables, type, name;\n\n  invariant(\n    !!document && !!document.kind,\n    `Argument of %s passed to parser was not a valid GraphQL ` +\n      `DocumentNode. You may need to use 'graphql-tag' or another method ` +\n      `to convert your operation into a document`,\n    document\n  );\n\n  const fragments: DefinitionNode[] = [];\n  const queries: DefinitionNode[] = [];\n  const mutations: DefinitionNode[] = [];\n  const subscriptions: DefinitionNode[] = [];\n\n  for (const x of document.definitions) {\n    if (x.kind === \"FragmentDefinition\") {\n      fragments.push(x);\n      continue;\n    }\n\n    if (x.kind === \"OperationDefinition\") {\n      switch (x.operation) {\n        case \"query\":\n          queries.push(x);\n          break;\n        case \"mutation\":\n          mutations.push(x);\n          break;\n        case \"subscription\":\n          subscriptions.push(x);\n          break;\n      }\n    }\n  }\n\n  invariant(\n    !fragments.length ||\n      queries.length ||\n      mutations.length ||\n      subscriptions.length,\n    `Passing only a fragment to 'graphql' is not yet supported. ` +\n      `You must include a query, subscription or mutation as well`\n  );\n\n  invariant(\n    queries.length + mutations.length + subscriptions.length <= 1,\n    `react-apollo only supports a query, subscription, or a mutation per HOC. ` +\n      `%s had %s queries, %s ` +\n      `subscriptions and %s mutations. ` +\n      `You can use 'compose' to join multiple operation types to a component`,\n    document,\n    queries.length,\n    subscriptions.length,\n    mutations.length\n  );\n\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n\n  const definitions = queries.length\n    ? queries\n    : mutations.length\n    ? mutations\n    : subscriptions;\n\n  invariant(\n    definitions.length === 1,\n    `react-apollo only supports one definition per HOC. %s had ` +\n      `%s definitions. ` +\n      `You can use 'compose' to join multiple operation types to a component`,\n    document,\n    definitions.length\n  );\n\n  const definition = definitions[0] as OperationDefinitionNode;\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === \"Name\") {\n    name = definition.name.value;\n  } else {\n    name = \"data\"; // fallback to using data if no name\n  }\n\n  const payload = { name, type, variables };\n  cache.set(document, payload);\n  return payload;\n}\n\nexport function verifyDocumentType(document: DocumentNode, type: DocumentType) {\n  const operation = parser(document);\n  const requiredOperationName = operationName(type);\n  const usedOperationName = operationName(operation.type);\n  invariant(\n    operation.type === type,\n    `Running a %s requires a graphql ` + `%s, but a %s was used instead.`,\n    requiredOperationName,\n    requiredOperationName,\n    usedOperationName\n  );\n}\n", "import * as React from \"react\";\nimport type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport type {\n  MutationFunctionOptions,\n  MutationHookOptions,\n  MutationResult,\n  MutationTuple,\n  NoInfer,\n} from \"../types/types.js\";\n\nimport type {\n  ApolloCache,\n  DefaultContext,\n  OperationVariables,\n} from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\nexport function useMutation<\n  TData = any,\n  TVariables = OperationVariables,\n  TContext = DefaultContext,\n  TCache extends ApolloCache<any> = ApolloCache<any>,\n>(\n  mutation: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: MutationHookOptions<\n    NoInfer<TData>,\n    NoInfer<TVariables>,\n    TContext,\n    TCache\n  >\n): MutationTuple<TData, TVariables, TContext, TCache> {\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(mutation, DocumentType.Mutation);\n  const [result, setResult] = React.useState<Omit<MutationResult, \"reset\">>({\n    called: false,\n    loading: false,\n    client,\n  });\n\n  const ref = React.useRef({\n    result,\n    mutationId: 0,\n    isMounted: true,\n    client,\n    mutation,\n    options,\n  });\n\n  // TODO: Trying to assign these in a useEffect or useLayoutEffect breaks\n  // higher-order components.\n  {\n    Object.assign(ref.current, { client, options, mutation });\n  }\n\n  const execute = React.useCallback(\n    (\n      executeOptions: MutationFunctionOptions<\n        TData,\n        TVariables,\n        TContext,\n        TCache\n      > = {}\n    ) => {\n      const { options, mutation } = ref.current;\n      const baseOptions = { ...options, mutation };\n      const client = executeOptions.client || ref.current.client;\n\n      if (\n        !ref.current.result.loading &&\n        !baseOptions.ignoreResults &&\n        ref.current.isMounted\n      ) {\n        setResult(\n          (ref.current.result = {\n            loading: true,\n            error: void 0,\n            data: void 0,\n            called: true,\n            client,\n          })\n        );\n      }\n\n      const mutationId = ++ref.current.mutationId;\n      const clientOptions = mergeOptions(baseOptions, executeOptions as any);\n\n      return client\n        .mutate(clientOptions)\n        .then((response) => {\n          const { data, errors } = response;\n          const error =\n            errors && errors.length > 0\n              ? new ApolloError({ graphQLErrors: errors })\n              : void 0;\n\n          const onError =\n            executeOptions.onError || ref.current.options?.onError;\n\n          if (error && onError) {\n            onError(error, clientOptions);\n          }\n\n          if (\n            mutationId === ref.current.mutationId &&\n            !clientOptions.ignoreResults\n          ) {\n            const result = {\n              called: true,\n              loading: false,\n              data,\n              error,\n              client,\n            };\n\n            if (ref.current.isMounted && !equal(ref.current.result, result)) {\n              setResult((ref.current.result = result));\n            }\n          }\n\n          const onCompleted =\n            executeOptions.onCompleted || ref.current.options?.onCompleted;\n\n          if (!error) {\n            onCompleted?.(response.data!, clientOptions);\n          }\n\n          return response;\n        })\n        .catch((error) => {\n          if (mutationId === ref.current.mutationId && ref.current.isMounted) {\n            const result = {\n              loading: false,\n              error,\n              data: void 0,\n              called: true,\n              client,\n            };\n\n            if (!equal(ref.current.result, result)) {\n              setResult((ref.current.result = result));\n            }\n          }\n\n          const onError =\n            executeOptions.onError || ref.current.options?.onError;\n\n          if (onError) {\n            onError(error, clientOptions);\n\n            // TODO(brian): why are we returning this here???\n            return { data: void 0, errors: error };\n          }\n\n          throw error;\n        });\n    },\n    []\n  );\n\n  const reset = React.useCallback(() => {\n    if (ref.current.isMounted) {\n      setResult({ called: false, loading: false, client });\n    }\n  }, []);\n\n  React.useEffect(() => {\n    ref.current.isMounted = true;\n\n    return () => {\n      ref.current.isMounted = false;\n    };\n  }, []);\n\n  return [execute, { reset, ...result }];\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"react\";\nimport type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport { equal } from \"@wry/equality\";\n\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport type {\n  NoInfer,\n  SubscriptionHookOptions,\n  SubscriptionResult,\n} from \"../types/types.js\";\nimport type { OperationVariables } from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\nexport function useSubscription<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  subscription: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SubscriptionHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n) {\n  const hasIssuedDeprecationWarningRef = React.useRef(false);\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(subscription, DocumentType.Subscription);\n  const [result, setResult] = React.useState<\n    SubscriptionResult<TData, TVariables>\n  >({\n    loading: !options?.skip,\n    error: void 0,\n    data: void 0,\n    variables: options?.variables,\n  });\n\n  if (!hasIssuedDeprecationWarningRef.current) {\n    hasIssuedDeprecationWarningRef.current = true;\n\n    if (options?.onSubscriptionData) {\n      invariant.warn(\n        options.onData\n          ? \"'useSubscription' supports only the 'onSubscriptionData' or 'onData' option, but not both. Only the 'onData' option will be used.\"\n          : \"'onSubscriptionData' is deprecated and will be removed in a future major version. Please use the 'onData' option instead.\"\n      );\n    }\n\n    if (options?.onSubscriptionComplete) {\n      invariant.warn(\n        options.onComplete\n          ? \"'useSubscription' supports only the 'onSubscriptionComplete' or 'onComplete' option, but not both. Only the 'onComplete' option will be used.\"\n          : \"'onSubscriptionComplete' is deprecated and will be removed in a future major version. Please use the 'onComplete' option instead.\"\n      );\n    }\n  }\n\n  const [observable, setObservable] = React.useState(() => {\n    if (options?.skip) {\n      return null;\n    }\n\n    return client.subscribe({\n      query: subscription,\n      variables: options?.variables,\n      fetchPolicy: options?.fetchPolicy,\n      context: options?.context,\n    });\n  });\n\n  const canResetObservableRef = React.useRef(false);\n  React.useEffect(() => {\n    return () => {\n      canResetObservableRef.current = true;\n    };\n  }, []);\n\n  const ref = React.useRef({ client, subscription, options });\n  React.useEffect(() => {\n    let shouldResubscribe = options?.shouldResubscribe;\n    if (typeof shouldResubscribe === \"function\") {\n      shouldResubscribe = !!shouldResubscribe(options!);\n    }\n\n    if (options?.skip) {\n      if (\n        !options?.skip !== !ref.current.options?.skip ||\n        canResetObservableRef.current\n      ) {\n        setResult({\n          loading: false,\n          data: void 0,\n          error: void 0,\n          variables: options?.variables,\n        });\n        setObservable(null);\n        canResetObservableRef.current = false;\n      }\n    } else if (\n      (shouldResubscribe !== false &&\n        (client !== ref.current.client ||\n          subscription !== ref.current.subscription ||\n          options?.fetchPolicy !== ref.current.options?.fetchPolicy ||\n          !options?.skip !== !ref.current.options?.skip ||\n          !equal(options?.variables, ref.current.options?.variables))) ||\n      canResetObservableRef.current\n    ) {\n      setResult({\n        loading: true,\n        data: void 0,\n        error: void 0,\n        variables: options?.variables,\n      });\n      setObservable(\n        client.subscribe({\n          query: subscription,\n          variables: options?.variables,\n          fetchPolicy: options?.fetchPolicy,\n          context: options?.context,\n        })\n      );\n      canResetObservableRef.current = false;\n    }\n\n    Object.assign(ref.current, { client, subscription, options });\n  }, [client, subscription, options, canResetObservableRef.current]);\n\n  React.useEffect(() => {\n    if (!observable) {\n      return;\n    }\n\n    let subscriptionStopped = false;\n    const subscription = observable.subscribe({\n      next(fetchResult) {\n        if (subscriptionStopped) {\n          return;\n        }\n\n        const result = {\n          loading: false,\n          // TODO: fetchResult.data can be null but SubscriptionResult.data\n          // expects TData | undefined only\n          data: fetchResult.data!,\n          error: void 0,\n          variables: options?.variables,\n        };\n        setResult(result);\n\n        if (ref.current.options?.onData) {\n          ref.current.options.onData({\n            client,\n            data: result,\n          });\n        } else if (ref.current.options?.onSubscriptionData) {\n          ref.current.options.onSubscriptionData({\n            client,\n            subscriptionData: result,\n          });\n        }\n      },\n      error(error) {\n        if (!subscriptionStopped) {\n          setResult({\n            loading: false,\n            data: void 0,\n            error,\n            variables: options?.variables,\n          });\n          ref.current.options?.onError?.(error);\n        }\n      },\n      complete() {\n        if (!subscriptionStopped) {\n          if (ref.current.options?.onComplete) {\n            ref.current.options.onComplete();\n          } else if (ref.current.options?.onSubscriptionComplete) {\n            ref.current.options.onSubscriptionComplete();\n          }\n        }\n      },\n    });\n\n    return () => {\n      // immediately stop receiving subscription values, but do not unsubscribe\n      // until after a short delay in case another useSubscription hook is\n      // reusing the same underlying observable and is about to subscribe\n      subscriptionStopped = true;\n      setTimeout(() => {\n        subscription.unsubscribe();\n      });\n    };\n  }, [observable]);\n\n  return result;\n}\n", "import * as React from \"react\";\nimport type { ReactiveVar } from \"../../core/index.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\n\nexport function useReactiveVar<T>(rv: ReactiveVar<T>): T {\n  return useSyncExternalStore(\n    React.useCallback(\n      (update) => {\n        // By reusing the same onNext function in the nested call to\n        // rv.onNextChange(onNext), we can keep using the initial clean-up function\n        // returned by rv.onNextChange(function onNext(v){...}), without having to\n        // register the new clean-up function (returned by the nested\n        // rv.onNextChange(onNext)) with yet another callback.\n        return rv.onNextChange(function onNext() {\n          update();\n          rv.onNextChange(onNext);\n        });\n      },\n      [rv]\n    ),\n    rv,\n    rv\n  );\n}\n", "import * as React from \"react\";\nimport { equal } from \"@wry/equality\";\n\nimport type { DeepPartial } from \"../../utilities/index.js\";\nimport { mergeDeepArray } from \"../../utilities/index.js\";\nimport type {\n  Cache,\n  Reference,\n  StoreObject,\n  MissingTree,\n} from \"../../cache/index.js\";\n\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport type { OperationVariables } from \"../../core/index.js\";\nimport type { NoInfer } from \"../types/types.js\";\n\nexport interface UseFragmentOptions<TData, TVars>\n  extends Omit<\n      Cache.DiffOptions<NoInfer<TData>, NoInfer<TVars>>,\n      \"id\" | \"query\" | \"optimistic\" | \"previousResult\" | \"returnPartialData\"\n    >,\n    Omit<\n      Cache.ReadFragmentOptions<TData, TVars>,\n      \"id\" | \"variables\" | \"returnPartialData\"\n    > {\n  from: StoreObject | Reference | string;\n  // Override this field to make it optional (default: true).\n  optimistic?: boolean;\n}\n\nexport type UseFragmentResult<TData> =\n  | {\n      data: TData;\n      complete: true;\n      missing?: never;\n    }\n  | {\n      data: DeepPartial<TData>;\n      complete: false;\n      missing?: MissingTree;\n    };\n\nexport function useFragment<TData = any, TVars = OperationVariables>(\n  options: UseFragmentOptions<TData, TVars>\n): UseFragmentResult<TData> {\n  const { cache } = useApolloClient();\n\n  const { fragment, fragmentName, from, optimistic = true, ...rest } = options;\n\n  const diffOptions: Cache.DiffOptions<TData, TVars> = {\n    ...rest,\n    returnPartialData: true,\n    id: typeof from === \"string\" ? from : cache.identify(from),\n    query: cache[\"getFragmentDoc\"](fragment, fragmentName),\n    optimistic,\n  };\n\n  const resultRef = React.useRef<UseFragmentResult<TData>>();\n  let latestDiff = cache.diff<TData>(diffOptions);\n\n  // Used for both getSnapshot and getServerSnapshot\n  const getSnapshot = () => {\n    const latestDiffToResult = diffToResult(latestDiff);\n    return resultRef.current &&\n      equal(resultRef.current.data, latestDiffToResult.data)\n      ? resultRef.current\n      : (resultRef.current = latestDiffToResult);\n  };\n\n  return useSyncExternalStore(\n    (forceUpdate) => {\n      let lastTimeout = 0;\n      const unsubcribe = cache.watch({\n        ...diffOptions,\n        immediate: true,\n        callback(diff) {\n          if (!equal(diff, latestDiff)) {\n            resultRef.current = diffToResult((latestDiff = diff));\n            lastTimeout = setTimeout(forceUpdate) as any;\n          }\n        },\n      });\n      return () => {\n        unsubcribe();\n        clearTimeout(lastTimeout);\n      };\n    },\n    getSnapshot,\n    getSnapshot\n  );\n}\n\nfunction diffToResult<TData>(\n  diff: Cache.DiffResult<TData>\n): UseFragmentResult<TData> {\n  const result = {\n    data: diff.result!,\n    complete: !!diff.complete,\n  } as UseFragmentResult<TData>;\n\n  if (diff.missing) {\n    result.missing = mergeDeepArray(diff.missing.map((error) => error.missing));\n  }\n\n  return result;\n}\n", "import * as React from \"react\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport type {\n  ApolloClient,\n  ApolloQueryResult,\n  DocumentNode,\n  OperationVariables,\n  TypedDocumentNode,\n  WatchQueryFetchPolicy,\n  FetchMoreQueryOptions,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { ApolloError, NetworkStatus } from \"../../core/index.js\";\nimport type { DeepPartial } from \"../../utilities/index.js\";\nimport { isNonEmptyArray } from \"../../utilities/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport type {\n  SuspenseQueryHookOptions,\n  ObservableQueryFields,\n  NoInfer,\n} from \"../types/types.js\";\nimport { __use, useDeepMemo } from \"./internal/index.js\";\nimport { getSuspenseCache } from \"../cache/index.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nimport { skipToken } from \"./constants.js\";\nimport type { SkipToken } from \"./constants.js\";\nimport type { CacheKey } from \"../cache/types.js\";\n\nexport interface UseSuspenseQueryResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> {\n  client: ApolloClient<any>;\n  data: TData;\n  error: ApolloError | undefined;\n  fetchMore: FetchMoreFunction<TData, TVariables>;\n  networkStatus: NetworkStatus;\n  refetch: RefetchFunction<TData, TVariables>;\n  subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n}\n\nexport type FetchMoreFunction<TData, TVariables extends OperationVariables> = (\n  fetchMoreOptions: FetchMoreQueryOptions<TVariables, TData> & {\n    updateQuery?: (\n      previousQueryResult: TData,\n      options: {\n        fetchMoreResult: TData;\n        variables: TVariables;\n      }\n    ) => TData;\n  }\n) => Promise<ApolloQueryResult<TData>>;\n\nexport type RefetchFunction<\n  TData,\n  TVariables extends OperationVariables,\n> = ObservableQueryFields<TData, TVariables>[\"refetch\"];\n\nexport type SubscribeToMoreFunction<\n  TData,\n  TVariables extends OperationVariables,\n> = ObservableQueryFields<TData, TVariables>[\"subscribeToMore\"];\n\nexport function useSuspenseQuery<\n  TData,\n  TVariables extends OperationVariables,\n  TOptions extends Omit<SuspenseQueryHookOptions<TData>, \"variables\">,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> &\n    TOptions\n): UseSuspenseQueryResult<\n  TOptions[\"errorPolicy\"] extends \"ignore\" | \"all\"\n    ? TOptions[\"returnPartialData\"] extends true\n      ? DeepPartial<TData> | undefined\n      : TData | undefined\n    : TOptions[\"returnPartialData\"] extends true\n    ? TOptions[\"skip\"] extends boolean\n      ? DeepPartial<TData> | undefined\n      : DeepPartial<TData>\n    : TOptions[\"skip\"] extends boolean\n    ? TData | undefined\n    : TData,\n  TVariables\n>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    skip: boolean;\n    returnPartialData: true;\n  }\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n  }\n): UseSuspenseQueryResult<DeepPartial<TData>, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    skip: boolean;\n  }\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): UseSuspenseQueryResult<TData, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n        returnPartialData: true;\n      })\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?:\n    | SkipToken\n    | SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken & Partial<SuspenseQueryHookOptions<TData, TVariables>>)\n    | SuspenseQueryHookOptions<TData, TVariables> = Object.create(null)\n): UseSuspenseQueryResult<TData | undefined, TVariables> {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions({ client, query, options });\n  const { fetchPolicy, variables } = watchQueryOptions;\n  const { queryKey = [] } = options;\n\n  const cacheKey: CacheKey = [\n    query,\n    canonicalStringify(variables),\n    ...([] as any[]).concat(queryKey),\n  ];\n\n  const queryRef = suspenseCache.getQueryRef(cacheKey, () =>\n    client.watchQuery(watchQueryOptions)\n  );\n\n  const [promiseCache, setPromiseCache] = React.useState(\n    () => new Map([[queryRef.key, queryRef.promise]])\n  );\n\n  let promise = promiseCache.get(queryRef.key);\n\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    promise = queryRef.applyOptions(watchQueryOptions);\n    promiseCache.set(queryRef.key, promise);\n  }\n\n  if (!promise) {\n    promise = queryRef.promise;\n    promiseCache.set(queryRef.key, promise);\n  }\n\n  React.useEffect(() => {\n    const dispose = queryRef.retain();\n\n    const removeListener = queryRef.listen((promise) => {\n      setPromiseCache((promiseCache) =>\n        new Map(promiseCache).set(queryRef.key, promise)\n      );\n    });\n\n    return () => {\n      removeListener();\n      dispose();\n    };\n  }, [queryRef]);\n\n  const skipResult = React.useMemo(() => {\n    const error = toApolloError(queryRef.result);\n\n    return {\n      loading: false,\n      data: queryRef.result.data,\n      networkStatus: error ? NetworkStatus.error : NetworkStatus.ready,\n      error,\n    };\n  }, [queryRef.result]);\n\n  const result = fetchPolicy === \"standby\" ? skipResult : __use(promise);\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      const promise = queryRef.fetchMore(options);\n\n      setPromiseCache((previousPromiseCache) =>\n        new Map(previousPromiseCache).set(queryRef.key, queryRef.promise)\n      );\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = queryRef.refetch(variables);\n\n      setPromiseCache((previousPromiseCache) =>\n        new Map(previousPromiseCache).set(queryRef.key, queryRef.promise)\n      );\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  const subscribeToMore: SubscribeToMoreFunction<TData, TVariables> =\n    React.useCallback(\n      (options) => queryRef.observable.subscribeToMore(options),\n      [queryRef]\n    );\n\n  return React.useMemo(() => {\n    return {\n      client,\n      data: result.data,\n      error: toApolloError(result),\n      networkStatus: result.networkStatus,\n      fetchMore,\n      refetch,\n      subscribeToMore,\n    };\n  }, [client, fetchMore, refetch, result, subscribeToMore]);\n}\n\nfunction validateOptions(options: WatchQueryOptions) {\n  const { query, fetchPolicy, returnPartialData } = options;\n\n  verifyDocumentType(query, DocumentType.Query);\n  validateFetchPolicy(fetchPolicy);\n  validatePartialDataReturn(fetchPolicy, returnPartialData);\n}\n\nfunction validateFetchPolicy(\n  fetchPolicy: WatchQueryFetchPolicy = \"cache-first\"\n) {\n  const supportedFetchPolicies: WatchQueryFetchPolicy[] = [\n    \"cache-first\",\n    \"network-only\",\n    \"no-cache\",\n    \"cache-and-network\",\n  ];\n\n  invariant(\n    supportedFetchPolicies.includes(fetchPolicy),\n    `The fetch policy \\`%s\\` is not supported with suspense.`,\n    fetchPolicy\n  );\n}\n\nfunction validatePartialDataReturn(\n  fetchPolicy: WatchQueryFetchPolicy | undefined,\n  returnPartialData: boolean | undefined\n) {\n  if (fetchPolicy === \"no-cache\" && returnPartialData) {\n    invariant.warn(\n      \"Using `returnPartialData` with a `no-cache` fetch policy has no effect. To read partial data from the cache, consider using an alternate fetch policy.\"\n    );\n  }\n}\n\nexport function toApolloError(result: ApolloQueryResult<any>) {\n  return isNonEmptyArray(result.errors)\n    ? new ApolloError({ graphQLErrors: result.errors })\n    : result.error;\n}\n\ninterface UseWatchQueryOptionsHookOptions<\n  TData,\n  TVariables extends OperationVariables,\n> {\n  client: ApolloClient<unknown>;\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  options: SkipToken | SuspenseQueryHookOptions<TData, TVariables>;\n}\n\nexport function useWatchQueryOptions<\n  TData,\n  TVariables extends OperationVariables,\n>({\n  client,\n  query,\n  options,\n}: UseWatchQueryOptionsHookOptions<TData, TVariables>): WatchQueryOptions<\n  TVariables,\n  TData\n> {\n  return useDeepMemo<WatchQueryOptions<TVariables, TData>>(() => {\n    if (options === skipToken) {\n      return { query, fetchPolicy: \"standby\" };\n    }\n\n    const fetchPolicy =\n      options.fetchPolicy ||\n      client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\";\n\n    const watchQueryOptions = {\n      ...options,\n      fetchPolicy,\n      query,\n      notifyOnNetworkStatusChange: false,\n      nextFetchPolicy: void 0,\n    };\n\n    if (__DEV__) {\n      validateOptions(watchQueryOptions);\n    }\n\n    // Assign the updated fetch policy after our validation since `standby` is\n    // not a supported fetch policy on its own without the use of `skip`.\n    if (options.skip) {\n      watchQueryOptions.fetchPolicy = \"standby\";\n    }\n\n    return watchQueryOptions;\n  }, [client, options, query]);\n}\n", "import type { DependencyList } from \"react\";\nimport * as React from \"react\";\nimport { equal } from \"@wry/equality\";\n\nexport function useDeepMemo<TValue>(\n  memoFn: () => TValue,\n  deps: DependencyList\n) {\n  const ref = React.useRef<{ deps: DependencyList; value: TValue }>();\n\n  if (!ref.current || !equal(ref.current.deps, deps)) {\n    ref.current = { value: memoFn(), deps };\n  }\n\n  return ref.current.value;\n}\n", "import * as React from \"react\";\nimport { canUseDOM } from \"../../../utilities/index.js\";\n\n// use canUseDOM here instead of canUseLayoutEffect because we want to be able\n// to use useLayoutEffect in our jest tests. useLayoutEffect seems to work fine\n// in useSuspenseQuery tests, but to honor the original comment about the\n// warnings for useSyncExternalStore implementation, canUseLayoutEffect is left\n// alone.\nexport const useIsomorphicLayoutEffect = canUseDOM\n  ? React.useLayoutEffect\n  : React.useEffect;\n", "import { wrapPromiseWithState } from \"../../../utilities/index.js\";\nimport * as React from \"react\";\n\ntype Use = <T>(promise: Promise<T>) => T;\n// Prevent webpack from complaining about our feature detection of the\n// use property of the React namespace, which is expected not\n// to exist when using current stable versions, and that's fine.\nconst useKey = \"use\" as keyof typeof React;\nconst realHook = React[useKey] as Use | undefined;\n\n// This is named with two underscores to allow this hook to evade typical rules of\n// hooks (i.e. it can be used conditionally)\nexport const __use =\n  realHook ||\n  function __use<TValue>(promise: Promise<TValue>) {\n    const statefulPromise = wrapPromiseWithState(promise);\n\n    switch (statefulPromise.status) {\n      case \"pending\":\n        throw statefulPromise;\n      case \"rejected\":\n        throw statefulPromise.reason;\n      case \"fulfilled\":\n        return statefulPromise.value;\n    }\n  };\n", "import { equal } from \"@wry/equality\";\nimport type {\n  ApolloError,\n  ApolloQueryResult,\n  ObservableQuery,\n  OperationVariables,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { isNetworkRequestSettled } from \"../../core/index.js\";\nimport type { ObservableSubscription } from \"../../utilities/index.js\";\nimport {\n  createFulfilledPromise,\n  createRejectedPromise,\n} from \"../../utilities/index.js\";\nimport type { CacheKey } from \"./types.js\";\nimport type { useBackgroundQuery, useReadQuery } from \"../hooks/index.js\";\n\ntype Listener<TData> = (promise: Promise<ApolloQueryResult<TData>>) => void;\n\ntype FetchMoreOptions<TData> = Parameters<\n  ObservableQuery<TData>[\"fetchMore\"]\n>[0];\n\nconst QUERY_REFERENCE_SYMBOL: unique symbol = Symbol();\n/**\n * A `QueryReference` is an opaque object returned by {@link useBackgroundQuery}.\n * A child component reading the `QueryReference` via {@link useReadQuery} will\n * suspend until the promise resolves.\n */\nexport interface QueryReference<TData = unknown> {\n  [QUERY_REFERENCE_SYMBOL]: InternalQueryReference<TData>;\n}\n\ninterface InternalQueryReferenceOptions {\n  key: CacheKey;\n  onDispose?: () => void;\n  autoDisposeTimeoutMs?: number;\n}\n\nexport function wrapQueryRef<TData>(\n  internalQueryRef: InternalQueryReference<TData>\n): QueryReference<TData> {\n  return { [QUERY_REFERENCE_SYMBOL]: internalQueryRef };\n}\n\nexport function unwrapQueryRef<TData>(\n  queryRef: QueryReference<TData>\n): InternalQueryReference<TData> {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\n\nconst OBSERVED_CHANGED_OPTIONS = [\n  \"canonizeResults\",\n  \"context\",\n  \"errorPolicy\",\n  \"fetchPolicy\",\n  \"refetchWritePolicy\",\n  \"returnPartialData\",\n] as const;\n\ntype ObservedOptions = Pick<\n  WatchQueryOptions,\n  (typeof OBSERVED_CHANGED_OPTIONS)[number]\n>;\n\nexport class InternalQueryReference<TData = unknown> {\n  public result: ApolloQueryResult<TData>;\n  public readonly key: CacheKey;\n  public readonly observable: ObservableQuery<TData>;\n\n  public promiseCache?: Map<CacheKey, Promise<ApolloQueryResult<TData>>>;\n  public promise: Promise<ApolloQueryResult<TData>>;\n\n  private subscription: ObservableSubscription;\n  private listeners = new Set<Listener<TData>>();\n  private autoDisposeTimeoutId: NodeJS.Timeout;\n  private status: \"idle\" | \"loading\" = \"loading\";\n\n  private resolve: ((result: ApolloQueryResult<TData>) => void) | undefined;\n  private reject: ((error: unknown) => void) | undefined;\n\n  private references = 0;\n\n  constructor(\n    observable: ObservableQuery<TData>,\n    options: InternalQueryReferenceOptions\n  ) {\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable;\n    // Don't save this result as last result to prevent delivery of last result\n    // when first subscribing\n    this.result = observable.getCurrentResult(false);\n    this.key = options.key;\n\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n\n    if (\n      isNetworkRequestSettled(this.result.networkStatus) ||\n      (this.result.data &&\n        (!this.result.partial || this.watchQueryOptions.returnPartialData))\n    ) {\n      this.promise = createFulfilledPromise(this.result);\n      this.status = \"idle\";\n    } else {\n      this.promise = new Promise((resolve, reject) => {\n        this.resolve = resolve;\n        this.reject = reject;\n      });\n    }\n\n    this.subscription = observable\n      .filter(({ data }) => !equal(data, {}))\n      .subscribe({\n        next: this.handleNext,\n        error: this.handleError,\n      });\n\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    const startDisposeTimer = () => {\n      if (!this.references) {\n        this.autoDisposeTimeoutId = setTimeout(\n          this.dispose,\n          options.autoDisposeTimeoutMs ?? 30_000\n        );\n      }\n    };\n\n    // We wait until the request has settled to ensure we don't dispose of the\n    // query ref before the request finishes, otherwise we would leave the\n    // promise in a pending state rendering the suspense boundary indefinitely.\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n\n  get watchQueryOptions() {\n    return this.observable.options;\n  }\n\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n\n    return () => {\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.references--;\n\n      // Wait before fully disposing in case the app is running in strict mode.\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  didChangeOptions(watchQueryOptions: ObservedOptions) {\n    return OBSERVED_CHANGED_OPTIONS.some(\n      (option) =>\n        !equal(this.watchQueryOptions[option], watchQueryOptions[option])\n    );\n  }\n\n  applyOptions(watchQueryOptions: ObservedOptions) {\n    const {\n      fetchPolicy: currentFetchPolicy,\n      canonizeResults: currentCanonizeResults,\n    } = this.watchQueryOptions;\n\n    // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n    if (\n      currentFetchPolicy === \"standby\" &&\n      currentFetchPolicy !== watchQueryOptions.fetchPolicy\n    ) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.silentSetOptions(watchQueryOptions);\n\n      if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {\n        this.result = { ...this.result, ...this.observable.getCurrentResult() };\n        this.promise = createFulfilledPromise(this.result);\n      }\n    }\n\n    return this.promise;\n  }\n\n  listen(listener: Listener<TData>) {\n    this.listeners.add(listener);\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  refetch(variables: OperationVariables | undefined) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  }\n\n  fetchMore(options: FetchMoreOptions<TData>) {\n    return this.initiateFetch(this.observable.fetchMore<TData>(options));\n  }\n\n  private dispose() {\n    this.subscription.unsubscribe();\n    this.onDispose();\n  }\n\n  private onDispose() {\n    // noop. overridable by options\n  }\n\n  private handleNext(result: ApolloQueryResult<TData>) {\n    switch (this.status) {\n      case \"loading\": {\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n        this.status = \"idle\";\n        this.result = result;\n        this.resolve?.(result);\n        break;\n      }\n      case \"idle\": {\n        // This occurs when switching to a result that is fully cached when this\n        // class is instantiated. ObservableQuery will run reobserve when\n        // subscribing, which delivers a result from the cache.\n        if (result.data === this.result.data) {\n          return;\n        }\n\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n\n        this.result = result;\n        this.promise = createFulfilledPromise(result);\n        this.deliver(this.promise);\n        break;\n      }\n    }\n  }\n\n  private handleError(error: ApolloError) {\n    this.subscription.unsubscribe();\n    this.subscription = this.observable.resubscribeAfterError(\n      this.handleNext,\n      this.handleError\n    );\n\n    switch (this.status) {\n      case \"loading\": {\n        this.status = \"idle\";\n        this.reject?.(error);\n        break;\n      }\n      case \"idle\": {\n        this.promise = createRejectedPromise(error);\n        this.deliver(this.promise);\n      }\n    }\n  }\n\n  private deliver(promise: Promise<ApolloQueryResult<TData>>) {\n    this.listeners.forEach((listener) => listener(promise));\n  }\n\n  private initiateFetch(returnedPromise: Promise<ApolloQueryResult<TData>>) {\n    this.status = \"loading\";\n\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n\n    this.promise.catch(() => {});\n\n    // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situtation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n    returnedPromise\n      .then((result) => {\n        if (this.status === \"loading\") {\n          this.status = \"idle\";\n          this.result = result;\n          this.resolve?.(result);\n        }\n      })\n      .catch(() => {});\n\n    return returnedPromise;\n  }\n}\n", "import { Trie } from \"@wry/trie\";\nimport type { ObservableQuery } from \"../../core/index.js\";\nimport { canUseWeakMap } from \"../../utilities/index.js\";\nimport { InternalQueryReference } from \"./QueryReference.js\";\nimport type { CacheKey } from \"./types.js\";\n\nexport interface SuspenseCacheOptions {\n  /**\n   * Specifies the amount of time, in milliseconds, the suspense cache will wait\n   * for a suspended component to read from the suspense cache before it\n   * automatically disposes of the query. This prevents memory leaks when a\n   * component unmounts before a suspended resource finishes loading. Increase\n   * the timeout if your queries take longer than than the specified time to\n   * prevent your queries from suspending over and over.\n   *\n   * Defaults to 30 seconds.\n   */\n  autoDisposeTimeoutMs?: number;\n}\n\nexport class SuspenseCache {\n  private queryRefs = new Trie<{ current?: InternalQueryReference }>(\n    canUseWeakMap\n  );\n  private options: SuspenseCacheOptions;\n\n  constructor(options: SuspenseCacheOptions = Object.create(null)) {\n    this.options = options;\n  }\n\n  getQueryRef<TData = any>(\n    cacheKey: CacheKey,\n    createObservable: () => ObservableQuery<TData>\n  ) {\n    const ref = this.queryRefs.lookupArray(cacheKey);\n\n    if (!ref.current) {\n      ref.current = new InternalQueryReference(createObservable(), {\n        key: cacheKey,\n        autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,\n        onDispose: () => {\n          delete ref.current;\n        },\n      });\n    }\n\n    return ref.current as InternalQueryReference<TData>;\n  }\n}\n", "import type { SuspenseCacheOptions } from \"./index.js\";\nimport { SuspenseCache } from \"./SuspenseCache.js\";\nimport type { ApolloClient } from \"../../core/ApolloClient.js\";\n\ndeclare module \"../../core/ApolloClient.js\" {\n  interface DefaultOptions {\n    react?: {\n      suspense?: Readonly<SuspenseCacheOptions>;\n    };\n  }\n}\n\nconst suspenseCacheSymbol = Symbol.for(\"apollo.suspenseCache\");\n\nexport function getSuspenseCache(\n  client: ApolloClient<object> & {\n    [suspenseCacheSymbol]?: SuspenseCache;\n  }\n) {\n  if (!client[suspenseCacheSymbol]) {\n    client[suspenseCacheSymbol] = new SuspenseCache(\n      client.defaultOptions.react?.suspense\n    );\n  }\n\n  return client[suspenseCacheSymbol];\n}\n", "export const skipToken = Symbol.for(\"apollo.skipToken\");\nexport type SkipToken = typeof skipToken;\n", "import * as React from \"react\";\nimport type {\n  DocumentNode,\n  OperationVariables,\n  TypedDocumentNode,\n} from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { wrapQueryRef } from \"../cache/QueryReference.js\";\nimport type { QueryReference } from \"../cache/QueryReference.js\";\nimport type { BackgroundQueryHookOptions, NoInfer } from \"../types/types.js\";\nimport { __use } from \"./internal/index.js\";\nimport { getSuspenseCache } from \"../cache/index.js\";\nimport { useWatchQueryOptions } from \"./useSuspenseQuery.js\";\nimport type { FetchMoreFunction, RefetchFunction } from \"./useSuspenseQuery.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nimport type { DeepPartial } from \"../../utilities/index.js\";\nimport type { CacheKey } from \"../cache/types.js\";\nimport type { SkipToken } from \"./constants.js\";\n\nexport type UseBackgroundQueryResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> = {\n  fetchMore: FetchMoreFunction<TData, TVariables>;\n  refetch: RefetchFunction<TData, TVariables>;\n};\n\ntype BackgroundQueryHookOptionsNoInfer<\n  TData,\n  TVariables extends OperationVariables,\n> = BackgroundQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>;\n\nexport function useBackgroundQuery<\n  TData,\n  TVariables extends OperationVariables,\n  TOptions extends Omit<BackgroundQueryHookOptions<TData>, \"variables\">,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & TOptions\n): [\n  (\n    | QueryReference<\n        TOptions[\"errorPolicy\"] extends \"ignore\" | \"all\"\n          ? TOptions[\"returnPartialData\"] extends true\n            ? DeepPartial<TData> | undefined\n            : TData | undefined\n          : TOptions[\"returnPartialData\"] extends true\n          ? DeepPartial<TData>\n          : TData\n      >\n    | (TOptions[\"skip\"] extends boolean ? undefined : never)\n  ),\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    returnPartialData: true;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): [\n  QueryReference<DeepPartial<TData> | undefined>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): [\n  QueryReference<TData | undefined>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    skip: boolean;\n    returnPartialData: true;\n  }\n): [\n  QueryReference<DeepPartial<TData>> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    returnPartialData: true;\n  }\n): [\n  QueryReference<DeepPartial<TData>>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    skip: boolean;\n  }\n): [\n  QueryReference<TData> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: BackgroundQueryHookOptionsNoInfer<TData, TVariables>\n): [QueryReference<TData>, UseBackgroundQueryResult<TData, TVariables>];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SkipToken\n): [undefined, UseBackgroundQueryResult<TData, TVariables>];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n        returnPartialData: true;\n      })\n): [\n  QueryReference<DeepPartial<TData>> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SkipToken | BackgroundQueryHookOptionsNoInfer<TData, TVariables>\n): [\n  QueryReference<TData> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken &\n        Partial<BackgroundQueryHookOptionsNoInfer<TData, TVariables>>)\n    | BackgroundQueryHookOptionsNoInfer<TData, TVariables> = Object.create(null)\n): [\n  QueryReference<TData> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n] {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions({ client, query, options });\n  const { fetchPolicy, variables } = watchQueryOptions;\n  const { queryKey = [] } = options;\n\n  // This ref tracks the first time query execution is enabled to determine\n  // whether to return a query ref or `undefined`. When initialized\n  // in a skipped state (either via `skip: true` or `skipToken`) we return\n  // `undefined` for the `queryRef` until the query has been enabled. Once\n  // enabled, a query ref is always returned regardless of whether the query is\n  // skipped again later.\n  const didFetchResult = React.useRef(fetchPolicy !== \"standby\");\n  didFetchResult.current ||= fetchPolicy !== \"standby\";\n\n  const cacheKey: CacheKey = [\n    query,\n    canonicalStringify(variables),\n    ...([] as any[]).concat(queryKey),\n  ];\n\n  const queryRef = suspenseCache.getQueryRef(cacheKey, () =>\n    client.watchQuery(watchQueryOptions)\n  );\n\n  const [promiseCache, setPromiseCache] = React.useState(\n    () => new Map([[queryRef.key, queryRef.promise]])\n  );\n\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    const promise = queryRef.applyOptions(watchQueryOptions);\n    promiseCache.set(queryRef.key, promise);\n  }\n\n  React.useEffect(() => queryRef.retain(), [queryRef]);\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      const promise = queryRef.fetchMore(options);\n\n      setPromiseCache((promiseCache) =>\n        new Map(promiseCache).set(queryRef.key, queryRef.promise)\n      );\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = queryRef.refetch(variables);\n\n      setPromiseCache((promiseCache) =>\n        new Map(promiseCache).set(queryRef.key, queryRef.promise)\n      );\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  queryRef.promiseCache = promiseCache;\n\n  const wrappedQueryRef = React.useMemo(\n    () => wrapQueryRef(queryRef),\n    [queryRef]\n  );\n\n  return [\n    didFetchResult.current ? wrappedQueryRef : void 0,\n    { fetchMore, refetch },\n  ];\n}\n", "import * as React from \"react\";\nimport { unwrapQueryRef } from \"../cache/QueryReference.js\";\nimport type { QueryReference } from \"../cache/QueryReference.js\";\nimport { __use } from \"./internal/index.js\";\nimport { toApolloError } from \"./useSuspenseQuery.js\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\n\nexport function useReadQuery<TData>(queryRef: QueryReference<TData>) {\n  const internalQueryRef = unwrapQueryRef(queryRef);\n  invariant(\n    internalQueryRef.promiseCache,\n    \"It appears that `useReadQuery` was used outside of `useBackgroundQuery`. \" +\n      \"`useReadQuery` is only supported for use with `useBackgroundQuery`. \" +\n      \"Please ensure you are passing the `queryRef` returned from `useBackgroundQuery`.\"\n  );\n\n  const { promiseCache, key } = internalQueryRef;\n\n  if (!promiseCache.has(key)) {\n    promiseCache.set(key, internalQueryRef.promise);\n  }\n\n  const promise = useSyncExternalStore(\n    React.useCallback(\n      (forceUpdate) => {\n        return internalQueryRef.listen((promise) => {\n          internalQueryRef.promiseCache!.set(internalQueryRef.key, promise);\n          forceUpdate();\n        });\n      },\n      [internalQueryRef]\n    ),\n    () => promiseCache.get(key)!,\n    () => promiseCache.get(key)!\n  );\n\n  const result = __use(promise);\n\n  return React.useMemo(() => {\n    return {\n      data: result.data,\n      networkStatus: result.networkStatus,\n      error: toApolloError(result),\n    };\n  }, [result]);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAAA,SAAuB;;;ACFvB,YAAuB;AAevB,IAAM,aAAa,eACf,OAAO,IAAI,oBAAoB,IAC/B;AAEE,SAAU,mBAAgB;AAC9B,YACE,mBAAmB,OACnB,EAAA;MACE,UAAA,oBAAA,UAAA;MACA,CAAA,SAAA;AAEA,WAAA,eAAA,qBAAA,YAAA;MAGA,OAAW,UAAM,oBAEkB,CAAA,CAAA;MAClC,YAAS;MACZ,UAAO;MACL,cAAQ;;YAER,cAAe;;SAEd;;AAEJ,IAAA,qBAAA;;;AD7BI,IAAM,iBAAgD,SAAC,OAAK;AACjE,MAAM,gBAAgB,iBAAgB;AACtC,SACE,qBAAC,cAAc,UAAQ,MACpB,SAAC,SAAY;AACZ,cACE,WAAW,QAAQ,QACnB,EAAA;WACE,MAAA,SAAA,QAAA,MAAA;;;;;AEjBZ,IAAAC,SAAuB;AAUhB,IAAM,iBAAqD,SAAC,IAGlE;MAFC,SAAM,GAAA,QACN,WAAQ,GAAA;AAER,MAAM,gBAAgB,iBAAgB;AACtC,MAAM,gBAAsB,kBAAW,aAAa;AAEpD,MAAM,UAAgB,eAAQ,WAAA;AAC5B,WAAA,SAAA,SAAA,CAAA,GACK,aAAa,GAAA,EAChB,QAAQ,UAAU,cAAc,OAAM,CAAA;EAE1C,GAAG,CAAC,eAAe,MAAM,CAAC;AAE1B,YACE,QAAQ,QACR,EAAA;SACE,qBAAA,cAAA,UAAA,EAAA,OACF,QAAA,GAAA,QAAA;;;;AC7BJ,IAAAC,SAAuB;AAIjB,SAAU,gBACd,UAA+B;AAE/B,MAAM,UAAgB,kBAAW,iBAAgB,CAAE;AACnD,MAAM,SAAS,YAAY,QAAQ;AACnC,YACE,CAAC,CAAC,QACF,EAAA;SACE;;;;ACXN,IAAAC,SAAuB;;;ACAvB,IAAAC,SAAuB;;;ACDvB,IAAAC,SAAuB;AAIvB,IAAI,6BAA6B;AAYjC,IAAM,UAAU;AAChB,IAAM,WAAWC,OAAM,OAAO;AAMvB,IAAM,uBACX,YACC,SAAC,WAAW,aAAa,mBAAiB;AAKzC,MAAM,QAAQ,YAAW;AACzB,MAEE,WAAO,YAAA,SACP,CAAC,8BAGD,UAAU,YAAW,GACrB;AACA,iCAA6B;AAE7B,eAAU,YACR,SAAA,UAAA,MAAA,EAAA;;AAkBE,MAAA,KAAgC,gBAAS;IAC7C,MAAM,EAAE,OAAO,YAAW;GAC3B,GAFQ,OAAI,GAAA,CAAA,EAAA,MAAI,cAAW,GAAA,CAAA;AAO5B,MAAI,oBAAoB;AAKtB,IAAM,uBAAgB,WAAA;AACpB,aAAO,OAAO,MAAM,EAAE,OAAO,YAAW,CAAE;AAK1C,UAAI,uBAAuB,IAAI,GAAG;AAEhC,oBAAY,EAAE,KAAI,CAAE;;IAExB,GAAG,CAAC,WAAW,OAAO,WAAW,CAAC;SAC7B;AACL,WAAO,OAAO,MAAM,EAAE,OAAO,YAAW,CAAE;;AAG5C,EAAM,iBAAU,WAAA;AAGd,QAAI,uBAAuB,IAAI,GAAG;AAEhC,kBAAY,EAAE,KAAI,CAAE;;AAItB,WAAO,UAAU,SAAS,oBAAiB;AAQzC,UAAI,uBAAuB,IAAI,GAAG;AAEhC,oBAAY,EAAE,KAAI,CAAE;;IAExB,CAAC;EACH,GAAG,CAAC,SAAS,CAAC;AAEd,SAAO;AACT;AAEF,SAAS,uBAAiC,IAMzC;MALC,QAAK,GAAA,OACL,cAAW,GAAA;AAKX,MAAI;AACF,WAAO,UAAU,YAAW;WAC5B,IAAM;AACN,WAAO;;AAEX;;;ACtHA,IAAY;CAAZ,SAAYC,eAAY;AACtB,EAAAA,cAAAA,cAAA,OAAA,IAAA,CAAA,IAAA;AACA,EAAAA,cAAAA,cAAA,UAAA,IAAA,CAAA,IAAA;AACA,EAAAA,cAAAA,cAAA,cAAA,IAAA,CAAA,IAAA;AACF,GAJY,iBAAA,eAAY,CAAA,EAAA;AAYxB,IAAM,QAAQ,oBAAI,IAAG;AAEf,SAAU,cAAc,MAAkB;AAC9C,MAAI;AACJ,UAAQ,MAAM;IACZ,KAAK,aAAa;AAChB,aAAO;AACP;IACF,KAAK,aAAa;AAChB,aAAO;AACP;IACF,KAAK,aAAa;AAChB,aAAO;AACP;;AAEJ,SAAO;AACT;AAGM,SAAU,OAAO,UAAsB;AAC3C,MAAM,SAAS,MAAM,IAAI,QAAQ;AACjC,MAAI;AAAQ,WAAO;AAEnB,MAAI,WAAW,MAAM;AAErB,YACE,CAAC,CAAC,YAAY,CAAC,CAAC,SAAS,MACzB,IAAA,QAAA;MACE,YAAA,CAAA;MACA,UAAA,CAAA;AAIJ,MAAM,YAA8B,CAAA;AACpC,MAAM,gBAA+B,CAAA;AACrC,WAAM,KAAS,GAAqB,KAAG,SAAA,aAAA,KAAA,GAAA,QAAA,MAAA;AACjC,QAAA,IAAA,GAAA,EAAa;AAEnB,QAAgB,EAAA,SAAA,sBAAS;AAAd,gBAAC,KAAA,CAAA;AACN;;QAEF,EAAA,SAAS,uBAAA;AACV,cAAA,EAAA,WAAA;QAEK,KAAI;AACA,kBAAE,KAAW,CAAA;AACnB;aACE;AACA,oBAAM,KAAA,CAAA;AACR;aACE;AACA,wBAAM,KAAA,CAAA;AACR;;;;YAIH,CAAA,UAAA,UACF,QAAA,UAED,UACG,UACC,cAAc,QAAA,EAAA;;IAEd,QAAA,SAAc,UAChB,SAAA,cAAA,UAAA;IACE;IAGJ;IAGI,QAAA;IACA,cAAA;IACA,UAAA;EAOJ;AACA,SAAK,QAAQ,SAAW,aAAU,QAAM,aAAA;MAAE,CAAA,QAAO,UAAY,CAAC,UAAA;AAExD,WAAA,aAAc;MAClB,cAAS,QAAA,SACP,oBACA,SACA,YAGF;YAEE,YAAkB,WAAA,GAAA,IAAA,UAAA,YAAA,MAAA;MAClB,aAAA,YAAA,CAAA;AAKJ,cAAM,WAAa,uBAA0C,CAAA;AAC7D,MAAA,WAAY,QAAW,WAAA,KAAA,SAAyB,QAAC;AAE7C,WAAA,WAAe,KAAI;SAEtB;WAAM;;MAEN,UAAA,EAAA,MAAA,MAAA,UAAA;AAED,QAAM,IAAA,UAAgB,OAAA;AACtB,SAAM;;AAEP,SAAA,mBAAA,UAAA,MAAA;AAED,MAAM,YAAU,OAAA,QAAmB;AACjC,MAAM,wBAAmB,cAAU,IAAA;AACnC,MAAM,oBAAA,cAAwB,UAAoB,IAAA;AAClD;IACA,UACE,SAAU;IAMb;;;;;;;;AFxGc,IAAA,iBACX,OAAM,UAAA;AAEJ,SAAU,SAId,OACA,SAGuB;AAHvB,MAAA,YAAA,QAAA;AAAA,cAGI,uBAAO,OAAO,IAAI;EAAC;AAEvB,SAAO,iBAAiB,gBAAgB,QAAQ,MAAM,GAAG,KAAK,EAAE,SAC9D,OAAO;AAEX;AAEM,SAAU,iBACd,QACA,OAA0D;AAE1D,MAAM,WAAiB,cAAM;AAC7B,MACE,CAAC,SAAS,WACV,WAAW,SAAS,QAAQ,UAC5B,UAAU,SAAS,QAAQ,OAC3B;AACA,aAAS,UAAU,IAAI,cAAc,QAAQ,OAAO,SAAS,OAAO;;AAEtE,MAAM,QAAQ,SAAS;AAQvB,QAAM,mBAAyB,kBAAW,SAAC,MAAI;AAAK,WAAA,OAAO;EAAP,GAAU,CAAC,EAAE,CAAC;AAElE,SAAO;AACT;AAEA,IAAA,gBAAA,WAAA;AACE,WAAAC,eACkB,QACA,OAChB,UAA2C;AAH7C,QAAA,QAAA;AACkB,SAAA,SAAA;AACA,SAAA,QAAA;AAgClB,SAAA,cAAc,WAAA;AAAM,aAAA,MAAK,iBAAgB;IAArB;AAqQZ,SAAA,oBAAoB,gBAAgB;MAC1C,SAAS;MACT,MAAM;MACN,OAAO;MACP,eAAe,cAAc;KAC9B;AAEO,SAAA,oBAAoB,gBAAgB;MAC1C,SAAS;MACT,MAAM;MACN,OAAO;MACP,eAAe,cAAc;KAC9B;AAuLO,SAAA,qBAAqB,KAAK,gBAAgB,UAAU,KAAI;AAre9D,uBAAmB,OAAO,aAAa,KAAK;AAI5C,QAAM,iBAAiB,YAAY,SAAS;AAC5C,QAAM,eAAe,kBAAkB,eAAe;AACtD,QAAI,cAAc;AAChB,WAAK,eAAe;;EAExB;AASA,EAAAA,eAAA,UAAA,mBAAA,WAAA;AAEE,eAAU,YACR,SAAA,UAAA,KAAA,EAAA;EAEJ;AAQA,EAAAA,eAAA,UAAA,eAAA,SACE,SAEC;AAHH,QAAA,QAAA;;AAKE,QAAI,QAAQ,OAAO;AACjB,aAAO,OAAO,MAAM,EAAE,OAAO,QAAQ,MAAK,CAAE;;AAG9C,SAAK,oBAAoB,KAAK,wBAC3B,KAAK,mBAAmB,OAAQ;AAGnC,QAAM,UAAU,KAAK,WAAW,mBAC9B,KAAK,mBAAkB,CAAE;AAM3B,SAAK,iBAAe,KAAA,KAAK,YAAM,QAAA,OAAA,SAAA,SAAA,GAAE,SAAQ,KAAK;AAC9C,SAAK,SAAS;AACd,SAAK,YAAW;AAEhB,WAAO,IAAI,QAAwC,SAAC,SAAO;AACzD,UAAI;AAMJ,cAAQ,UAAU;QAChB,MAAM,SAAC,OAAK;AACV,mBAAS;QACX;QACA,OAAO,WAAA;AACL,kBAAQ,MAAK,cAAc,MAAK,WAAW,iBAAgB,CAAE,CAAC;QAChE;QACA,UAAU,WAAA;AACR,kBAAQ,MAAK,cAAc,MAAM,CAAC;QACpC;OACD;IACH,CAAC;EACH;AAKA,EAAAA,eAAA,UAAA,WAAA,SAAS,SAA4C;AAArD,QAAA,QAAA;AAQE,SAAK,iBAAuB,kBAAW,iBAAgB,CAAE,EAAE;AAE3D,SAAK,WAAW,OAAO;AAEvB,QAAM,WAAW,KAAK,mBAAkB;AAExC,QAAM,SAAS,qBACP,mBACJ,SAAC,mBAAiB;AAChB,UAAI,MAAK,gBAAgB;AACvB,eAAO,WAAA;QAAO;;AAGhB,YAAK,cAAc;AAEnB,UAAM,SAAS,WAAA;AACb,YAAM,iBAAiB,MAAK;AAI5B,YAAMC,UAAS,SAAS,iBAAgB;AAExC,YACE,kBACA,eAAe,YAAYA,QAAO,WAClC,eAAe,kBAAkBA,QAAO,iBACxC,MAAM,eAAe,MAAMA,QAAO,IAAI,GACtC;AACA;;AAGF,cAAK,UAAUA,OAAM;MACvB;AAEA,UAAM,UAAU,SAAC,OAAY;AAC3B,qBAAa,YAAW;AACxB,uBAAe,SAAS,sBAAsB,QAAQ,OAAO;AAE7D,YAAI,CAAC,eAAe,KAAK,OAAO,eAAe,GAAG;AAEhD,gBAAM;;AAGR,YAAM,iBAAiB,MAAK;AAC5B,YACE,CAAC,kBACA,kBAAkB,eAAe,WAClC,CAAC,MAAM,OAAO,eAAe,KAAK,GAClC;AACA,gBAAK,UAAU;YACb,MAAO,kBAAkB,eAAe;YACxC;YACA,SAAS;YACT,eAAe,cAAc;WAC9B;;MAEL;AAEA,UAAI,eAAe,SAAS,UAAU,QAAQ,OAAO;AAMrD,aAAO,WAAA;AACL,mBAAW,WAAA;AAAM,iBAAA,aAAa,YAAW;QAAxB,CAA0B;AAC3C,cAAK,cAAc,WAAA;AAAM,iBAAA,MAAK,iBAAgB;QAArB;MAC3B;IACF,GACA;MAOE;MACA,KAAK;MACL,KAAK,OAAO;KACb,GAGH,WAAA;AAAM,aAAA,MAAK,iBAAgB;IAArB,GACN,WAAA;AAAM,aAAA,MAAK,iBAAgB;IAArB,CAAuB;AAI/B,SAAK,2BAA2B,MAAM;AAEtC,WAAO,KAAK,cAAc,MAAM;EAClC;AAUQ,EAAAD,eAAA,UAAA,aAAR,SAAmB,SAA4C;;AAC7D,QAAM,oBAAoB,KAAK,wBAC5B,KAAK,mBAAmB,OAAQ;AAMnC,QAAM,2BAA2B,KAAK;AAEtC,QAAI,CAAC,MAAM,mBAAmB,wBAAwB,GAAG;AACvD,WAAK,oBAAoB;AAEzB,UAAI,4BAA4B,KAAK,YAAY;AAS/C,aAAK,WAAW,UAAU,KAAK,mBAAkB,CAAE;AAKnD,aAAK,iBAAe,KAAA,KAAK,YAAM,QAAA,OAAA,SAAA,SAAA,GAAE,SAAQ,KAAK;AAC9C,aAAK,SAAS;;;AAUlB,SAAK,cACH,QAAQ,eAAeA,eAAc,UAAU;AACjD,SAAK,UAAU,QAAQ,WAAWA,eAAc,UAAU;AAE1D,SACG,KAAK,kBAAkB,KAAK,OAAO,0BACpC,KAAK,iBAAiB,QAAQ,SAC9B,CAAC,KAAK,iBAAiB,MACvB;AAGA,WAAK,SAAS,KAAK;eAEnB,KAAK,iBAAiB,QACtB,KAAK,kBAAkB,gBAAgB,WACvC;AAWA,WAAK,SAAS,KAAK;eAEnB,KAAK,WAAW,KAAK,qBACrB,KAAK,WAAW,KAAK,mBACrB;AACA,WAAK,SAAS;;EAElB;AAEQ,EAAAA,eAAA,UAAA,qBAAR,WAAA;AACE,QAAM,UAAgE,CAAA;AAEtE,QAAM,iBAAiB,KAAK,OAAO,eAAe;AAClD,QAAI;AAAgB,cAAQ,KAAK,cAAc;AAE/C,QAAI,KAAK,iBAAiB,gBAAgB;AACxC,cAAQ,KAAK,KAAK,iBAAiB,cAAc;;AAanD,YAAQ,KACN,QACE,KAAK,cAAc,KAAK,WAAW,SACnC,KAAK,iBAAiB,CACvB;AAGH,WAAO,QAAQ,OAAO,YAAY;EACpC;AAiBQ,EAAAA,eAAA,UAAA,0BAAR,SAAgC,IAUW;;AAVX,QAAA,OAAA,QAAA;AAAA,WAAA,CAAA;IAUW;AATzC,QAAA,OAAI,GAAA,MACJ,MAAG,GAAA,KACH,cAAW,GAAA,aACX,UAAO,GAAA,SACP,iBAAc,GAAA,gBAIX,eAAY,OAAA,IATe,CAAA,QAAA,OAAA,eAAA,WAAA,gBAAA,CAU/B;AAMC,QAAM,oBACJ,OAAO,OAAO,cAAc,EAAE,OAAO,KAAK,MAAK,CAAE;AAEnD,QACE,KAAK,mBACJ,kBAAkB,gBAAgB,kBACjC,kBAAkB,gBAAgB,sBACpC;AAGA,wBAAkB,cAAc;;AAGlC,QAAI,CAAC,kBAAkB,WAAW;AAChC,wBAAkB,YAAY,CAAA;;AAGhC,QAAI,MAAM;AAEN,UAAA,KAEE,kBAAiB,aAFnB,cAAW,OAAA,SAAG,KAAK,sBAAqB,IAAE,IAC1C,KACE,kBAAiB,oBADnB,qBAAkB,OAAA,SAAG,cAAW;AAMlC,aAAO,OAAO,mBAAmB;QAC/B;QACA,aAAa;OACd;eACQ,CAAC,kBAAkB,aAAa;AACzC,wBAAkB,gBAChB,KAAA,KAAK,gBAAU,QAAA,OAAA,SAAA,SAAA,GAAE,QAAQ,uBACzB,KAAK,sBAAqB;;AAG9B,WAAO;EACT;AAEA,EAAAA,eAAA,UAAA,wBAAA,WAAA;;AACE,aACE,KAAA,KAAK,iBAAiB,oBAAc,QAAA,OAAA,SAAA,SAAA,GAAE,kBACtC,KAAA,KAAK,OAAO,eAAe,gBAAU,QAAA,OAAA,SAAA,SAAA,GAAE,gBACvC;EAEJ;AAKQ,EAAAA,eAAA,UAAA,cAAR,SAAoB,MAAW;EAAG;AAC1B,EAAAA,eAAA,UAAA,UAAR,SAAgB,OAAkB;EAAG;AAQ7B,EAAAA,eAAA,UAAA,qBAAR,WAAA;AAIE,QAAM,WAAY,KAAK,aACpB,KAAK,kBACJ,KAAK,eAAe,iBAAiB,KAAK,iBAAiB,KAC7D,KAAK,cACL,KAAK,OAAO,WAAW,KAAK,mBAAkB,CAAE;AAElD,SAAK,iBAAuB,eAC1B,WAAA;AAAM,aAAC;QACL,SAAS,SAAS,QAAQ,KAAK,QAAQ;QACvC,WAAW,SAAS,UAAU,KAAK,QAAQ;QAC3C,WAAW,SAAS,UAAU,KAAK,QAAQ;QAC3C,aAAa,SAAS,YAAY,KAAK,QAAQ;QAC/C,cAAc,SAAS,aAAa,KAAK,QAAQ;QACjD,aAAa,SAAS,YAAY,KAAK,QAAQ;QAC/C,iBAAiB,SAAS,gBAAgB,KAAK,QAAQ;;IAPnD,GASN,CAAC,QAAQ,CAAC;AAGZ,QAAM,aAAa,EACjB,KAAK,iBAAiB,QAAQ,SAAS,KAAK,iBAAiB;AAG/D,QAAI,KAAK,kBAAkB,YAAY;AACrC,WAAK,eAAe,sBAAsB,QAAQ;AAElD,UAAI,SAAS,iBAAgB,EAAG,SAAS;AAEvC,aAAK,eAAe,0BAA0B,QAAQ;;;AAI1D,WAAO;EACT;AAOQ,EAAAA,eAAA,UAAA,YAAR,SAAkB,YAAoC;AACpD,QAAM,iBAAiB,KAAK;AAC5B,QAAI,kBAAkB,eAAe,MAAM;AACzC,WAAK,eAAe,eAAe;;AAErC,SAAK,SAAS;AAGd,SAAK,YAAW;AAChB,SAAK,uBAAuB,YAAY,cAAc;EACxD;AAEQ,EAAAA,eAAA,UAAA,yBAAR,SACE,QACA,gBAAyC;AAF3C,QAAA,QAAA;AAIE,QAAI,CAAC,OAAO,SAAS;AACnB,UAAM,UAAQ,KAAK,cAAc,MAAM;AAGvC,cAAQ,QAAO,EACZ,KAAK,WAAA;AACJ,YAAI,SAAO;AACT,gBAAK,QAAQ,OAAK;mBAElB,OAAO,SACP,mBAAc,QAAd,mBAAc,SAAA,SAAd,eAAgB,mBAAkB,OAAO,iBACzC,OAAO,kBAAkB,cAAc,OACvC;AACA,gBAAK,YAAY,OAAO,IAAI;;MAEhC,CAAC,EACA,MAAM,SAAC,OAAK;AACX,mBAAU,YAAY,SAAA,UAAA,KAAA,KAAA;MACxB,CAAC;;EAEP;AAEQ,EAAAA,eAAA,UAAA,gBAAR,SACE,QAAgC;AAEhC,WAAO,gBAAgB,OAAO,MAAM,IAChC,IAAI,YAAY,EAAE,eAAe,OAAO,OAAM,CAAE,IAChD,OAAO;EACb;AAEQ,EAAAA,eAAA,UAAA,mBAAR,WAAA;AAIE,QAAI,CAAC,KAAK,QAAQ;AAChB,WAAK,uBACF,KAAK,SAAS,KAAK,WAAW,iBAAgB,CAAG;;AAGtD,WAAO,KAAK;EACd;AAUA,EAAAA,eAAA,UAAA,gBAAA,SACE,QAAgC;AAEhC,QAAI,cAAc,KAAK,mBAAmB,IAAI,MAAM;AACpD,QAAI;AAAa,aAAO;AAEhB,QAAA,OAA2C,OAAM,MAA3C,UAAqC,OAAM,SAA/B,uBAAoB,OAAK,QAA7C,CAAA,QAAA,SAAA,CAA0C;AAChD,SAAK,mBAAmB,IACtB,QACC,cAAW,SAAA,SAAA,SAAA,EACV,KAAI,GACD,oBAAoB,GACpB,KAAK,cAAc,GAAA,EACtB,QAAQ,KAAK,QACb,YAAY,KAAK,YACjB,WAAW,KAAK,WAAW,WAC3B,QAAQ,CAAC,KAAK,iBAAiB,MAC/B,cAAc,KAAK,aAAY,CAAA,CAC/B;AAGJ,QAAI,CAAC,YAAY,SAAS,gBAAgB,OAAO,MAAM,GAAG;AAKxD,kBAAY,QAAQ,IAAI,YAAY,EAAE,eAAe,OAAO,OAAM,CAAE;;AAGtE,WAAO;EACT;AAEQ,EAAAA,eAAA,UAAA,6BAAR,SAAmC,QAAgC;AAMjE,QACE,OAAO,WACP,KAAK,iBAAiB,kBACtB,CAAC,OAAO,YACP,CAAC,OAAO,QAAQ,OAAO,KAAK,OAAO,IAAI,EAAE,WAAW,MACrD,KAAK,WAAW,QAAQ,gBAAgB,cACxC;AACA,aAAO,OAAO,QAAQ;QACpB,SAAS;QACT,eAAe,cAAc;OAC9B;AACD,WAAK,WAAW,QAAO;;EAE3B;AACF,SAAAA;AAAA,EApiBA;;;ADjEA,IAAM,gBAAgB;EACpB;EACA;EACA;EACA;EACA;EACA;;AAGI,SAAU,aAId,OACA,SAAmE;;AAEnE,MAAM,iBACE,cAAM;AACd,MAAM,aAAmB,cAAM;AAC/B,MAAM,WAAiB,cAAM;AAG7B,MAAM,SAAS,aAAa,SAAS,eAAe,WAAW,CAAA,CAAE;AACjE,MAAM,YAAW,KAAA,WAAM,QAAN,WAAM,SAAA,SAAN,OAAQ,WAAK,QAAA,OAAA,SAAA,KAAI;AAIlC,aAAW,UAAU;AACrB,WAAS,UAAU;AAEnB,MAAM,gBAAgB,iBACpB,gBAAgB,WAAW,QAAQ,MAAM,GACzC,QAAQ;AAGV,MAAM,iBAAiB,cAAc,SAAQ,SAAA,SAAA,CAAA,GACxC,MAAM,GAAA,EACT,MAAM,CAAC,eAAe,QAAO,CAAA,CAAA;AAG/B,MAAM,qBACJ,eAAe,WAAW,QAAQ,sBAClC,cAAc,sBAAqB;AAErC,MAAM,SAAyC,OAAO,OAAO,gBAAgB;IAC3E,QAAQ,CAAC,CAAC,eAAe;GAC1B;AAGD,MAAM,eAAqB,eAAQ,WAAA;AACjC,QAAME,gBAAoC,CAAA;2BAC/BC,MAAG;AACZ,UAAM,SAAS,OAAOA,IAAG;AACzB,MAAAD,cAAaC,IAAG,IAAI,WAAA;AAClB,YAAI,CAAC,eAAe,SAAS;AAC3B,yBAAe,UAAU,uBAAO,OAAO,IAAI;AAE3C,wBAAc,iBAAgB;;AAEhC,eAAO,OAAO,MAAM,MAAM,SAAS;MACrC;;AATF,aAAkB,KAAA,GAAA,kBAAA,eAAA,KAAA,gBAAA,QAAA,MAAa;AAA1B,UAAM,MAAG,gBAAA,EAAA;cAAH,GAAG;;AAYd,WAAOD;EACT,GAAG,CAAA,CAAE;AAEL,SAAO,OAAO,QAAQ,YAAY;AAElC,MAAME,WAAgB,mBACpB,SAAC,gBAAc;AACb,mBAAe,UAAU,iBACtB,SAAA,SAAA,CAAA,GACM,cAAc,GAAA,EACjB,aAAa,eAAe,eAAe,mBAAkB,CAAA,IAE/D;MACE,aAAa;;AAGnB,QAAMC,WAAU,aAAa,WAAW,SAAO,SAAA,EAC7C,OAAO,SAAS,QAAO,GACpB,eAAe,OAAO,CAAA;AAG3B,QAAM,UAAU,cACb,aAAY,SAAA,SAAA,CAAA,GAAMA,QAAO,GAAA,EAAE,MAAM,MAAK,CAAA,CAAA,EACtC,KAAK,SAAC,aAAW;AAAK,aAAA,OAAO,OAAO,aAAa,YAAY;IAAvC,CAAwC;AAIjE,YAAQ,MAAM,WAAA;IAAO,CAAC;AAEtB,WAAO;EACT,GACA,CAAA,CAAE;AAGJ,SAAO,CAACD,UAAS,MAAM;AACzB;;;AIpHA,IAAAE,SAAuB;AAsBjB,SAAU,YAMd,UACA,SAKC;AAED,MAAM,SAAS,gBAAgB,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS,MAAM;AAC9C,qBAAmB,UAAU,aAAa,QAAQ;AAC5C,MAAA,KAA4B,gBAAwC;IACxE,QAAQ;IACR,SAAS;IACT;GACD,GAJM,SAAM,GAAA,CAAA,GAAE,YAAS,GAAA,CAAA;AAMxB,MAAM,MAAY,cAAO;IACvB;IACA,YAAY;IACZ,WAAW;IACX;IACA;IACA;GACD;AAID;AACE,WAAO,OAAO,IAAI,SAAS,EAAE,QAAQ,SAAS,SAAQ,CAAE;;AAG1D,MAAMC,WAAgB,mBACpB,SACE,gBAKM;AALN,QAAA,mBAAA,QAAA;AAAA,uBAAA,CAAA;IAKM;AAEA,QAAAC,MAAwB,IAAI,SAA1BC,WAAOD,IAAA,SAAEE,YAAQF,IAAA;AACzB,QAAM,cAAW,SAAA,SAAA,CAAA,GAAQC,QAAO,GAAA,EAAE,UAAQC,UAAA,CAAA;AAC1C,QAAMC,UAAS,eAAe,UAAU,IAAI,QAAQ;AAEpD,QACE,CAAC,IAAI,QAAQ,OAAO,WACpB,CAAC,YAAY,iBACb,IAAI,QAAQ,WACZ;AACA,gBACG,IAAI,QAAQ,SAAS;QACpB,SAAS;QACT,OAAO;QACP,MAAM;QACN,QAAQ;QACR,QAAMA;OACN;;AAIN,QAAM,aAAa,EAAE,IAAI,QAAQ;AACjC,QAAM,gBAAgB,aAAa,aAAa,cAAqB;AAErE,WAAOA,QACJ,OAAO,aAAa,EACpB,KAAK,SAAC,UAAQ;;AACL,UAAA,OAAiB,SAAQ,MAAnB,SAAW,SAAQ;AACjC,UAAM,QACJ,UAAU,OAAO,SAAS,IACtB,IAAI,YAAY,EAAE,eAAe,OAAM,CAAE,IACzC;AAEN,UAAM,UACJ,eAAe,aAAWH,MAAA,IAAI,QAAQ,aAAO,QAAAA,QAAA,SAAA,SAAAA,IAAE;AAEjD,UAAI,SAAS,SAAS;AACpB,gBAAQ,OAAO,aAAa;;AAG9B,UACE,eAAe,IAAI,QAAQ,cAC3B,CAAC,cAAc,eACf;AACA,YAAM,WAAS;UACb,QAAQ;UACR,SAAS;UACT;UACA;UACA,QAAMG;;AAGR,YAAI,IAAI,QAAQ,aAAa,CAAC,MAAM,IAAI,QAAQ,QAAQ,QAAM,GAAG;AAC/D,oBAAW,IAAI,QAAQ,SAAS,QAAO;;;AAI3C,UAAM,cACJ,eAAe,iBAAe,KAAA,IAAI,QAAQ,aAAO,QAAA,OAAA,SAAA,SAAA,GAAE;AAErD,UAAI,CAAC,OAAO;AACV,wBAAW,QAAX,gBAAW,SAAA,SAAX,YAAc,SAAS,MAAO,aAAa;;AAG7C,aAAO;IACT,CAAC,EACA,MAAM,SAAC,OAAK;;AACX,UAAI,eAAe,IAAI,QAAQ,cAAc,IAAI,QAAQ,WAAW;AAClE,YAAM,WAAS;UACb,SAAS;UACT;UACA,MAAM;UACN,QAAQ;UACR,QAAMA;;AAGR,YAAI,CAAC,MAAM,IAAI,QAAQ,QAAQ,QAAM,GAAG;AACtC,oBAAW,IAAI,QAAQ,SAAS,QAAO;;;AAI3C,UAAM,UACJ,eAAe,aAAWH,MAAA,IAAI,QAAQ,aAAO,QAAAA,QAAA,SAAA,SAAAA,IAAE;AAEjD,UAAI,SAAS;AACX,gBAAQ,OAAO,aAAa;AAG5B,eAAO,EAAE,MAAM,QAAQ,QAAQ,MAAK;;AAGtC,YAAM;IACR,CAAC;EACL,GACA,CAAA,CAAE;AAGJ,MAAM,QAAc,mBAAY,WAAA;AAC9B,QAAI,IAAI,QAAQ,WAAW;AACzB,gBAAU,EAAE,QAAQ,OAAO,SAAS,OAAO,OAAM,CAAE;;EAEvD,GAAG,CAAA,CAAE;AAEL,EAAM,iBAAU,WAAA;AACd,QAAI,QAAQ,YAAY;AAExB,WAAO,WAAA;AACL,UAAI,QAAQ,YAAY;IAC1B;EACF,GAAG,CAAA,CAAE;AAEL,SAAO,CAACD,UAAO,SAAA,EAAI,MAAK,GAAK,MAAM,CAAA;AACrC;;;AClLA,IAAAK,SAAuB;AAcjB,SAAU,gBAId,cACA,SAAsE;AAEtE,MAAM,iCAAuC,cAAO,KAAK;AACzD,MAAM,SAAS,gBAAgB,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS,MAAM;AAC9C,qBAAmB,cAAc,aAAa,YAAY;AACpD,MAAA,KAA4B,gBAEhC;IACA,SAAS,EAAC,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS;IACnB,OAAO;IACP,MAAM;IACN,WAAW,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS;GACrB,GAPM,SAAM,GAAA,CAAA,GAAE,YAAS,GAAA,CAAA;AASxB,MAAI,CAAC,+BAA+B,SAAS;AAC3C,mCAA+B,UAAU;AAEzC,QAAI,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS,oBAAoB;AAC/B,iBAAU,YACA,SAAM,UAAA,KAAA,QAAA,SAAA,KAAA,EAAA;;oBAEV,QAAA,YAAA,SAAA,SAAA,QAAA,wBAAA;AAEP,iBAAA,YAAA,SAAA,UAAA,KAAA,QAAA,aAAA,KAAA,EAAA;IAED;;WAGQ,gBAAA,WAAA;oBACA,QAAA,YAAA,SAAA,SAAA,QAAA,MAAA;AAEP,aAAA;IACF;AAEK,WAA8B,OAAM,UAAS;MAC7C,OAAO;MACT,WAAW,YAAC,QAAA,YAAA,SAAA,SAAA,QAAA;MACb,aAAA,YAAA,QAAA,YAAA,SAAA,SAAA,QAAA;MAED,SAAa,YAAW,QAAA,YAAA,SAAA,SAAA,QAAA;;mBAEb,GAAE,CAAA,GAAA,gBAAA,GAAA,CAAA;8BACS,cAAP,KAAA;mBACN,WAAS;WACf,WAAA;AAVE,4BAAY,UAAa;IAa1B;EACN,GAAA,CAAA,CAAK;MACH,MAAO,cAAA,EAAA,QAAA,cAAA,QAAA,CAAA;mBACL,WAAA;AACF,QAAEC,KAAAC,KAAA,IAAA;AACD,QAAI,oBAAA,YAAA,QAAA,YAAA,SAAA,SAAA,QAAA;AAED,QAAG,OAAQ,sBAAgB,YAAE;AAC7B,0BAAU,CAAA,CAAA,kBAAA,OAAA;;AACd,QAAI,YAAA,QAAoB,YAAO,SAAP,SAAO,QAAA,MAAA;AAC3B,UAAA,EAAA,YAAO,QAAiB,YAAK,SAAY,SAAA,QAAA,UAAA,GAAAD,MAAA,IAAA,QAAA,aAAA,QAAAA,QAAA,SAAA,SAAAA,IAAA,SAC3C,sBAAsB,SAAA;AACvB,kBAAA;UAEU,SAAA;UAEN,MAAO;UACR,OAAA;UAEA,WAAU,YAAA,QAAA,YAAA,SAAA,SAAA,QAAA;;sBAEF,IAAM;8BACC,UAAA;;eAGf,sBAAoB,qBACpB,IAAA,QAAA,UACD,iBAAA,IAAA,QAAA,iBACF,YAAA,QAAA,YAAA,SAAA,SAAA,QAAA,mBAAAC,MAAA,IAAA,QAAA,aAAA,QAAAA,QAAA,SAAA,SAAAA,IAAA,gBAAM,EACJ,YAAA,QAAiB,YAAU,SAAA,SAAA,QAAA,UAAA,GAAA,KAAA,IAAA,QAAA,aAAA,QAAA,OAAA,SAAA,SAAA,GAAA,SACzB,CAAA,MAAM,YAAgB,QAAO,YAAA,SAAA,SAAA,QAAA,YAAA,KAAA,IAAA,QAAA,aAAA,QAAA,OAAA,SAAA,SAAA,GAAA,SAAA,4BACX,SAAI;gBACrB;QACA,SAAQ;QACR,MAAM;QACV,OAAA;QAEA,WAAU,YAAA,QAAA,YAAA,SAAA,SAAA,QAAA;;oBAEF,OAAM,UAAA;QACZ,OAAO;QACP,WAAW,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS;QACnB,aAAA,YAAA,QAAA,YAAA,SAAA,SAAA,QAAA;QACH,SAAa,YACJ,QAAU,YAAA,SAAA,SAAA,QAAA;;4BAEG,UAAA;;kBAElB,IAAS,SAAO,EAAA,QAAA,cAAP,QAAgB,CAAA;cAE3B,cAAA,SAAA,sBAAA,OAAA,CAAA;mBACF,WAAA;QACD,CAAA,YAAA;AAED;IACE;AAEJ,QAAM,sBAAU;AACd,QAAIC,gBAAa,WAAA,UAAA;MACf,MAAA,SAAO,aAAA;AACR,YAAAF,KAAAC;AAEG,YAAA,qBAA4B;AAC1B;QACA;;UACE,SAAA;UACF,MAAA,YAAO;UACR,OAAA;UAEK,WAAS,YAAA,QAAA,YAAA,SAAA,SAAA,QAAA;;kBAIPE,OAAA;aACNH,MAAK,IAAE,QAAM,aAAA,QAAAA,QAAA,SAAA,SAAAA,IAAA,QAAA;AACb,cAAA,QAAW,QAAO,OAAA;YAClB;YACF,MAAUG;UAEN,CAAA;oBAEAF,MAAM,IAAA,QAAA,aAAA,QAAAA,QAAA,SAAA,SAAAA,IAAA,oBAAA;cACN,QAAM,QAAM,mBAAA;YACX;YACJ,kBAAAE;WAAM;;;sBAGH,OAAA;iBACCF;YACJ,CAAA,qBAAA;AACF,oBAAA;YACI,SAAC;;YACC;YACH,WAAU,YAAA,QAAA,YAAA,SAAA,SAAA,QAAA;;kBAERD,MAAM,IAAM,QAAA,aAAA,QAAAA,QAAA,SAAA,SAAAA,IAAA,aAAA,QAAAC,QAAA,SAAA,SAAAA,IAAA,KAAAD,KAAA,KAAA;;;gBAGZ,WAAC;YACHA,KAAAC;YACD,CAAA,qBAAA;AACF,eAAAD,MAAA,IAAA,QAAA,aAAA,QAAAA,QAAA,SAAA,SAAAA,IAAA,YAAA;AACO,gBAAA,QAAA,QAAA,WAAA;sBACDC,MAAA,IAAA,QAAqB,aAAA,QAAAA,QAAA,SAAA,SAAAA,IAAA,wBAAA;AACpB,gBAAA,QAAI,QAAQ,uBAAO;;;;;sBAItB;4BACF;AACH,iBAAC,WAAA;AACA,QAAAC,cAAA,YAAA;MAEH,CAAA;;gBAKE,CAAA;;;;;ACzLN,IAAAE,UAAuB;AAIjB,SAAU,eAAkB,IAAkB;AAClD,SAAO,qBACC,oBACJ,SAAC,QAAM;AAML,WAAO,GAAG,aAAa,SAAS,SAAM;AACpC,aAAM;AACN,SAAG,aAAa,MAAM;IACxB,CAAC;EACH,GACA,CAAC,EAAE,CAAC,GAEN,IACA,EAAE;AAEN;;;ACvBA,IAAAC,UAAuB;AA2CjB,SAAU,YACd,SAAyC;AAEjC,MAAAC,SAAU,gBAAe,EAAE;AAE3B,MAAA,WAA6D,QAAO,UAA1D,eAAmD,QAAO,cAA5CC,QAAqC,QAAO,MAAtC,KAA+B,QAAO,YAAtC,aAAU,OAAA,SAAG,OAAI,IAAK,OAAI,OAAK,SAA/D,CAAA,YAAA,gBAAA,QAAA,YAAA,CAA4D;AAElE,MAAM,cAAW,SAAA,SAAA,CAAA,GACZ,IAAI,GAAA,EACP,mBAAmB,MACnB,IAAI,OAAOA,UAAS,WAAWA,QAAOD,OAAM,SAASC,KAAI,GACzD,OAAOD,OAAM,gBAAgB,EAAE,UAAU,YAAY,GACrD,WAAU,CAAA;AAGZ,MAAM,YAAkB,eAAM;AAC9B,MAAI,aAAaA,OAAM,KAAY,WAAW;AAG9C,MAAM,cAAc,WAAA;AAClB,QAAM,qBAAqB,aAAa,UAAU;AAClD,WAAO,UAAU,WACf,MAAM,UAAU,QAAQ,MAAM,mBAAmB,IAAI,IACnD,UAAU,UACT,UAAU,UAAU;EAC3B;AAEA,SAAO,qBACL,SAAC,aAAW;AACV,QAAI,cAAc;AAClB,QAAM,aAAaA,OAAM,MAAK,SAAA,SAAA,CAAA,GACzB,WAAW,GAAA,EACd,WAAW,MACX,UAAQ,SAAC,MAAI;AACX,UAAI,CAAC,MAAM,MAAM,UAAU,GAAG;AAC5B,kBAAU,UAAU,aAAc,aAAa,IAAK;AACpD,sBAAc,WAAW,WAAW;;IAExC,EAAC,CAAA,CAAA;AAEH,WAAO,WAAA;AACL,iBAAU;AACV,mBAAa,WAAW;IAC1B;EACF,GACA,aACA,WAAW;AAEf;AAEA,SAAS,aACP,MAA6B;AAE7B,MAAM,SAAS;IACb,MAAM,KAAK;IACX,UAAU,CAAC,CAAC,KAAK;;AAGnB,MAAI,KAAK,SAAS;AAChB,WAAO,UAAU,eAAe,KAAK,QAAQ,IAAI,SAAC,OAAK;AAAK,aAAA,MAAM;IAAN,CAAa,CAAC;;AAG5E,SAAO;AACT;;;AC1GA,IAAAE,UAAuB;;;ACCvB,IAAAC,UAAuB;AAGjB,SAAU,YACd,QACA,MAAoB;AAEpB,MAAM,MAAY,eAAM;AAExB,MAAI,CAAC,IAAI,WAAW,CAAC,MAAM,IAAI,QAAQ,MAAM,IAAI,GAAG;AAClD,QAAI,UAAU,EAAE,OAAO,OAAM,GAAI,KAAI;;AAGvC,SAAO,IAAI,QAAQ;AACrB;;;ACfA,IAAAC,UAAuB;;;ACCvB,IAAAC,UAAuB;AAMvB,IAAM,SAAS;AACf,IAAMC,YAAWD,QAAM,MAAM;AAItB,IAAM,QACXC,aACA,SAASC,OAAc,SAAwB;AAC7C,MAAM,kBAAkB,qBAAqB,OAAO;AAEpD,UAAQ,gBAAgB,QAAQ;IAC9B,KAAK;AACH,YAAM;IACR,KAAK;AACH,YAAM,gBAAgB;IACxB,KAAK;AACH,aAAO,gBAAgB;;AAE7B;;;ACFF,IAAM,yBAAwC,OAAM;AAgB9C,SAAU,aACd,kBAA+C;;AAE/C,SAAA,KAAA,CAAA,GAAS,GAAC,sBAAsB,IAAG,kBAAgB;AACrD;AAEM,SAAU,eACd,UAA+B;AAE/B,SAAO,SAAS,sBAAsB;AACxC;AAEA,IAAM,2BAA2B;EAC/B;EACA;EACA;EACA;EACA;EACA;;AAQF,IAAA,yBAAA,WAAA;AAkBE,WAAAC,wBACE,YACA,SAAsC;AAFxC,QAAA,QAAA;AATQ,SAAA,YAAY,oBAAI,IAAG;AAEnB,SAAA,SAA6B;AAK7B,SAAA,aAAa;AAMnB,SAAK,aAAa,KAAK,WAAW,KAAK,IAAI;AAC3C,SAAK,cAAc,KAAK,YAAY,KAAK,IAAI;AAC7C,SAAK,UAAU,KAAK,QAAQ,KAAK,IAAI;AACrC,SAAK,aAAa;AAGlB,SAAK,SAAS,WAAW,iBAAiB,KAAK;AAC/C,SAAK,MAAM,QAAQ;AAEnB,QAAI,QAAQ,WAAW;AACrB,WAAK,YAAY,QAAQ;;AAG3B,QACE,wBAAwB,KAAK,OAAO,aAAa,KAChD,KAAK,OAAO,SACV,CAAC,KAAK,OAAO,WAAW,KAAK,kBAAkB,oBAClD;AACA,WAAK,UAAU,uBAAuB,KAAK,MAAM;AACjD,WAAK,SAAS;WACT;AACL,WAAK,UAAU,IAAI,QAAQ,SAAC,SAAS,QAAM;AACzC,cAAK,UAAU;AACf,cAAK,SAAS;MAChB,CAAC;;AAGH,SAAK,eAAe,WACjB,OAAO,SAAC,IAAQ;UAAN,OAAI,GAAA;AAAO,aAAA,CAAC,MAAM,MAAM,CAAA,CAAE;IAAf,CAAgB,EACrC,UAAU;MACT,MAAM,KAAK;MACX,OAAO,KAAK;KACb;AAMH,QAAM,oBAAoB,WAAA;;AACxB,UAAI,CAAC,MAAK,YAAY;AACpB,cAAK,uBAAuB,WAC1B,MAAK,UACL,KAAA,QAAQ,0BAAoB,QAAA,OAAA,SAAA,KAAI,GAAM;;IAG5C;AAKA,SAAK,QAAQ,KAAK,mBAAmB,iBAAiB;EACxD;AAEA,SAAA,eAAIA,wBAAA,WAAA,qBAAiB;SAArB,WAAA;AACE,aAAO,KAAK,WAAW;IACzB;;;;AAEA,EAAAA,wBAAA,UAAA,SAAA,WAAA;AAAA,QAAA,QAAA;AACE,SAAK;AACL,iBAAa,KAAK,oBAAoB;AACtC,QAAI,WAAW;AAEf,WAAO,WAAA;AACL,UAAI,UAAU;AACZ;;AAGF,iBAAW;AACX,YAAK;AAGL,iBAAW,WAAA;AACT,YAAI,CAAC,MAAK,YAAY;AACpB,gBAAK,QAAO;;MAEhB,CAAC;IACH;EACF;AAEA,EAAAA,wBAAA,UAAA,mBAAA,SAAiB,mBAAkC;AAAnD,QAAA,QAAA;AACE,WAAO,yBAAyB,KAC9B,SAAC,QAAM;AACL,aAAA,CAAC,MAAM,MAAK,kBAAkB,MAAM,GAAG,kBAAkB,MAAM,CAAC;IAAhE,CAAiE;EAEvE;AAEA,EAAAA,wBAAA,UAAA,eAAA,SAAa,mBAAkC;AACvC,QAAA,KAGF,KAAK,mBAFM,qBAAkB,GAAA,aACd,yBAAsB,GAAA;AAKzC,QACE,uBAAuB,aACvB,uBAAuB,kBAAkB,aACzC;AACA,WAAK,cAAc,KAAK,WAAW,UAAU,iBAAiB,CAAC;WAC1D;AACL,WAAK,WAAW,iBAAiB,iBAAiB;AAElD,UAAI,2BAA2B,kBAAkB,iBAAiB;AAChE,aAAK,SAAM,SAAA,SAAA,CAAA,GAAQ,KAAK,MAAM,GAAK,KAAK,WAAW,iBAAgB,CAAE;AACrE,aAAK,UAAU,uBAAuB,KAAK,MAAM;;;AAIrD,WAAO,KAAK;EACd;AAEA,EAAAA,wBAAA,UAAA,SAAA,SAAO,UAAyB;AAAhC,QAAA,QAAA;AACE,SAAK,UAAU,IAAI,QAAQ;AAE3B,WAAO,WAAA;AACL,YAAK,UAAU,OAAO,QAAQ;IAChC;EACF;AAEA,EAAAA,wBAAA,UAAA,UAAA,SAAQ,WAAyC;AAC/C,WAAO,KAAK,cAAc,KAAK,WAAW,QAAQ,SAAS,CAAC;EAC9D;AAEA,EAAAA,wBAAA,UAAA,YAAA,SAAU,SAAgC;AACxC,WAAO,KAAK,cAAc,KAAK,WAAW,UAAiB,OAAO,CAAC;EACrE;AAEQ,EAAAA,wBAAA,UAAA,UAAR,WAAA;AACE,SAAK,aAAa,YAAW;AAC7B,SAAK,UAAS;EAChB;AAEQ,EAAAA,wBAAA,UAAA,YAAR,WAAA;EAEA;AAEQ,EAAAA,wBAAA,UAAA,aAAR,SAAmB,QAAgC;;AACjD,YAAQ,KAAK,QAAQ;MACnB,KAAK,WAAW;AAGd,YAAI,OAAO,SAAS,QAAQ;AAC1B,iBAAO,OAAO,KAAK,OAAO;;AAE5B,aAAK,SAAS;AACd,aAAK,SAAS;AACd,SAAA,KAAA,KAAK,aAAO,QAAA,OAAA,SAAA,SAAA,GAAA,KAAA,MAAG,MAAM;AACrB;;MAEF,KAAK,QAAQ;AAIX,YAAI,OAAO,SAAS,KAAK,OAAO,MAAM;AACpC;;AAKF,YAAI,OAAO,SAAS,QAAQ;AAC1B,iBAAO,OAAO,KAAK,OAAO;;AAG5B,aAAK,SAAS;AACd,aAAK,UAAU,uBAAuB,MAAM;AAC5C,aAAK,QAAQ,KAAK,OAAO;AACzB;;;EAGN;AAEQ,EAAAA,wBAAA,UAAA,cAAR,SAAoB,OAAkB;;AACpC,SAAK,aAAa,YAAW;AAC7B,SAAK,eAAe,KAAK,WAAW,sBAClC,KAAK,YACL,KAAK,WAAW;AAGlB,YAAQ,KAAK,QAAQ;MACnB,KAAK,WAAW;AACd,aAAK,SAAS;AACd,SAAA,KAAA,KAAK,YAAM,QAAA,OAAA,SAAA,SAAA,GAAA,KAAA,MAAG,KAAK;AACnB;;MAEF,KAAK,QAAQ;AACX,aAAK,UAAU,sBAAsB,KAAK;AAC1C,aAAK,QAAQ,KAAK,OAAO;;;EAG/B;AAEQ,EAAAA,wBAAA,UAAA,UAAR,SAAgB,SAA0C;AACxD,SAAK,UAAU,QAAQ,SAAC,UAAQ;AAAK,aAAA,SAAS,OAAO;IAAhB,CAAiB;EACxD;AAEQ,EAAAA,wBAAA,UAAA,gBAAR,SAAsB,iBAAkD;AAAxE,QAAA,QAAA;AACE,SAAK,SAAS;AAEd,SAAK,UAAU,IAAI,QAAQ,SAAC,SAAS,QAAM;AACzC,YAAK,UAAU;AACf,YAAK,SAAS;IAChB,CAAC;AAED,SAAK,QAAQ,MAAM,WAAA;IAAO,CAAC;AAO3B,oBACG,KAAK,SAAC,QAAM;;AACX,UAAI,MAAK,WAAW,WAAW;AAC7B,cAAK,SAAS;AACd,cAAK,SAAS;AACd,SAAA,KAAA,MAAK,aAAO,QAAA,OAAA,SAAA,SAAA,GAAA,KAAA,OAAG,MAAM;;IAEzB,CAAC,EACA,MAAM,WAAA;IAAO,CAAC;AAEjB,WAAO;EACT;AACF,SAAAA;AAAA,EApPA;;;AC7CA,IAAA,gBAAA,WAAA;AAME,WAAAC,eAAY,SAAmD;AAAnD,QAAA,YAAA,QAAA;AAAA,gBAAgC,uBAAO,OAAO,IAAI;IAAC;AALvD,SAAA,YAAY,IAAI,KACtB,aAAa;AAKb,SAAK,UAAU;EACjB;AAEA,EAAAA,eAAA,UAAA,cAAA,SACE,UACA,kBAA8C;AAE9C,QAAM,MAAM,KAAK,UAAU,YAAY,QAAQ;AAE/C,QAAI,CAAC,IAAI,SAAS;AAChB,UAAI,UAAU,IAAI,uBAAuB,iBAAgB,GAAI;QAC3D,KAAK;QACL,sBAAsB,KAAK,QAAQ;QACnC,WAAW,WAAA;AACT,iBAAO,IAAI;QACb;OACD;;AAGH,WAAO,IAAI;EACb;AACF,SAAAA;AAAA,EA5BA;;;ACRA,IAAM,sBAAsB,OAAO,IAAI,sBAAsB;AAEvD,SAAU,iBACd,QAEC;;AAED,MAAI,CAAC,OAAO,mBAAmB,GAAG;AAChC,WAAO,mBAAmB,IAAI,IAAI,eAChC,KAAA,OAAO,eAAe,WAAK,QAAA,OAAA,SAAA,SAAA,GAAE,QAAQ;;AAIzC,SAAO,OAAO,mBAAmB;AACnC;;;AC1BO,IAAM,YAAY,OAAO,IAAI,kBAAkB;;;APyKhD,SAAU,iBAId,OACA,SAEqE;AAFrE,MAAA,YAAA,QAAA;AAAA,cAEkD,uBAAO,OAAO,IAAI;EAAC;AAErE,MAAM,SAAS,gBAAgB,QAAQ,MAAM;AAC7C,MAAM,gBAAgB,iBAAiB,MAAM;AAC7C,MAAM,oBAAoB,qBAAqB,EAAE,QAAQ,OAAO,QAAO,CAAE;AACjE,MAAA,cAA2B,kBAAiB,aAA/B,YAAc,kBAAiB;AAC5C,MAAA,KAAkB,QAAO,UAAzB,WAAQ,OAAA,SAAG,CAAA,IAAE;AAErB,MAAM,WAAQ,cAAA;IACZ;IACA,mBAAmB,SAAS;KACxB,CAAA,EAAa,OAAO,QAAQ,GAAC,IAAA;AAGnC,MAAM,WAAW,cAAc,YAAY,UAAU,WAAA;AACnD,WAAA,OAAO,WAAW,iBAAiB;EAAnC,CAAoC;AAGhC,MAAA,KAAwC,iBAC5C,WAAA;AAAM,WAAA,oBAAI,IAAI,CAAC,CAAC,SAAS,KAAK,SAAS,OAAO,CAAC,CAAC;EAA1C,CAA2C,GAD5C,eAAY,GAAA,CAAA,GAAE,kBAAe,GAAA,CAAA;AAIpC,MAAI,UAAU,aAAa,IAAI,SAAS,GAAG;AAE3C,MAAI,SAAS,iBAAiB,iBAAiB,GAAG;AAChD,cAAU,SAAS,aAAa,iBAAiB;AACjD,iBAAa,IAAI,SAAS,KAAK,OAAO;;AAGxC,MAAI,CAAC,SAAS;AACZ,cAAU,SAAS;AACnB,iBAAa,IAAI,SAAS,KAAK,OAAO;;AAGxC,EAAM,kBAAU,WAAA;AACd,QAAM,UAAU,SAAS,OAAM;AAE/B,QAAM,iBAAiB,SAAS,OAAO,SAACC,UAAO;AAC7C,sBAAgB,SAACC,eAAY;AAC3B,eAAA,IAAI,IAAIA,aAAY,EAAE,IAAI,SAAS,KAAKD,QAAO;MAA/C,CAAgD;IAEpD,CAAC;AAED,WAAO,WAAA;AACL,qBAAc;AACd,cAAO;IACT;EACF,GAAG,CAAC,QAAQ,CAAC;AAEb,MAAM,aAAmB,gBAAQ,WAAA;AAC/B,QAAM,QAAQ,cAAc,SAAS,MAAM;AAE3C,WAAO;MACL,SAAS;MACT,MAAM,SAAS,OAAO;MACtB,eAAe,QAAQ,cAAc,QAAQ,cAAc;MAC3D;;EAEJ,GAAG,CAAC,SAAS,MAAM,CAAC;AAEpB,MAAM,SAAS,gBAAgB,YAAY,aAAa,MAAM,OAAO;AAErE,MAAM,YAAwD,oBAC5D,SAACE,UAAO;AACN,QAAMF,WAAU,SAAS,UAAUE,QAAO;AAE1C,oBAAgB,SAAC,sBAAoB;AACnC,aAAA,IAAI,IAAI,oBAAoB,EAAE,IAAI,SAAS,KAAK,SAAS,OAAO;IAAhE,CAAiE;AAGnE,WAAOF;EACT,GACA,CAAC,QAAQ,CAAC;AAGZ,MAAM,UAAoD,oBACxD,SAACG,YAAS;AACR,QAAMH,WAAU,SAAS,QAAQG,UAAS;AAE1C,oBAAgB,SAAC,sBAAoB;AACnC,aAAA,IAAI,IAAI,oBAAoB,EAAE,IAAI,SAAS,KAAK,SAAS,OAAO;IAAhE,CAAiE;AAGnE,WAAOH;EACT,GACA,CAAC,QAAQ,CAAC;AAGZ,MAAM,kBACE,oBACJ,SAACE,UAAO;AAAK,WAAA,SAAS,WAAW,gBAAgBA,QAAO;EAA3C,GACb,CAAC,QAAQ,CAAC;AAGd,SAAa,gBAAQ,WAAA;AACnB,WAAO;MACL;MACA,MAAM,OAAO;MACb,OAAO,cAAc,MAAM;MAC3B,eAAe,OAAO;MACtB;MACA;MACA;;EAEJ,GAAG,CAAC,QAAQ,WAAW,SAAS,QAAQ,eAAe,CAAC;AAC1D;AAEA,SAAS,gBAAgB,SAA0B;AACzC,MAAA,QAA0C,QAAO,OAA1C,cAAmC,QAAO,aAA7B,oBAAsB,QAAO;AAEzD,qBAAmB,OAAO,aAAa,KAAK;AAC5C,sBAAoB,WAAW;AAC/B,4BAA0B,aAAa,iBAAiB;AAC1D;AAEA,SAAS,oBACP,aAAkD;AAAlD,MAAA,gBAAA,QAAA;AAAA,kBAAA;EAAkD;AAElD,MAAM,yBAAkD;IACtD;IACA;IACA;IACA;;AAGF,YACE,uBAAuB,SAAS,WAAW,GAC3C,IAAA,WAAA;AAGJ;AAEA,SAAS,0BACP,aACA,mBAAsC;AAEtC,MAAI,gBAAgB,cAAc,mBAAmB;AACnD,eAAU,YACR,SAAA,UAAA,KAAA,EAAA;;AAGN;AAEM,SAAU,cAAc,QAA8B;AAC1D,SAAO,gBAAgB,OAAO,MAAM,IAChC,IAAI,YAAY,EAAE,eAAe,OAAO,OAAM,CAAE,IAChD,OAAO;AACb;AAWM,SAAU,qBAGd,IAImD;MAHnD,SAAM,GAAA,QACN,QAAK,GAAA,OACL,UAAO,GAAA;AAKP,SAAO,YAAkD,WAAA;;AACvD,QAAI,YAAY,WAAW;AACzB,aAAO,EAAE,OAAO,aAAa,UAAS;;AAGxC,QAAM,cACJ,QAAQ,iBACRE,MAAA,OAAO,eAAe,gBAAU,QAAAA,QAAA,SAAA,SAAAA,IAAE,gBAClC;AAEF,QAAM,oBAAiB,SAAA,SAAA,CAAA,GAClB,OAAO,GAAA,EACV,aACA,OACA,6BAA6B,OAC7B,iBAAiB,OAAM,CAAA;AAGzB,QAAI,WAAS,YAAA,OAAA;AACX,sBAAgB,iBAAiB;;AAKnC,QAAI,QAAQ,MAAM;AAChB,wBAAkB,cAAc;;AAGlC,WAAO;EACT,GAAG,CAAC,QAAQ,SAAS,KAAK,CAAC;AAC7B;;;AQvXA,IAAAC,UAAuB;AAoKjB,SAAU,mBAId,OACA,SAG8E;AAH9E,MAAA,YAAA,QAAA;AAAA,cAG2D,uBAAO,OAAO,IAAI;EAAC;AAK9E,MAAM,SAAS,gBAAgB,QAAQ,MAAM;AAC7C,MAAM,gBAAgB,iBAAiB,MAAM;AAC7C,MAAM,oBAAoB,qBAAqB,EAAE,QAAQ,OAAO,QAAO,CAAE;AACjE,MAAA,cAA2B,kBAAiB,aAA/B,YAAc,kBAAiB;AAC5C,MAAA,KAAkB,QAAO,UAAzB,WAAQ,OAAA,SAAG,CAAA,IAAE;AAQrB,MAAM,iBAAuB,eAAO,gBAAgB,SAAS;AAC7D,iBAAe,YAAf,eAAe,UAAY,gBAAgB;AAE3C,MAAM,WAAQ,cAAA;IACZ;IACA,mBAAmB,SAAS;KACxB,CAAA,EAAa,OAAO,QAAQ,GAAC,IAAA;AAGnC,MAAM,WAAW,cAAc,YAAY,UAAU,WAAA;AACnD,WAAA,OAAO,WAAW,iBAAiB;EAAnC,CAAoC;AAGhC,MAAA,KAAwC,iBAC5C,WAAA;AAAM,WAAA,oBAAI,IAAI,CAAC,CAAC,SAAS,KAAK,SAAS,OAAO,CAAC,CAAC;EAA1C,CAA2C,GAD5C,eAAY,GAAA,CAAA,GAAE,kBAAe,GAAA,CAAA;AAIpC,MAAI,SAAS,iBAAiB,iBAAiB,GAAG;AAChD,QAAM,UAAU,SAAS,aAAa,iBAAiB;AACvD,iBAAa,IAAI,SAAS,KAAK,OAAO;;AAGxC,EAAM,kBAAU,WAAA;AAAM,WAAA,SAAS,OAAM;EAAf,GAAmB,CAAC,QAAQ,CAAC;AAEnD,MAAM,YAAwD,oBAC5D,SAACC,UAAO;AACN,QAAMC,WAAU,SAAS,UAAUD,QAAO;AAE1C,oBAAgB,SAACE,eAAY;AAC3B,aAAA,IAAI,IAAIA,aAAY,EAAE,IAAI,SAAS,KAAK,SAAS,OAAO;IAAxD,CAAyD;AAG3D,WAAOD;EACT,GACA,CAAC,QAAQ,CAAC;AAGZ,MAAM,UAAoD,oBACxD,SAACE,YAAS;AACR,QAAMF,WAAU,SAAS,QAAQE,UAAS;AAE1C,oBAAgB,SAACD,eAAY;AAC3B,aAAA,IAAI,IAAIA,aAAY,EAAE,IAAI,SAAS,KAAK,SAAS,OAAO;IAAxD,CAAyD;AAG3D,WAAOD;EACT,GACA,CAAC,QAAQ,CAAC;AAGZ,WAAS,eAAe;AAExB,MAAM,kBAAwB,gBAC5B,WAAA;AAAM,WAAA,aAAa,QAAQ;EAArB,GACN,CAAC,QAAQ,CAAC;AAGZ,SAAO;IACL,eAAe,UAAU,kBAAkB;IAC3C,EAAE,WAAW,QAAO;;AAExB;;;AC1PA,IAAAG,UAAuB;AAQjB,SAAU,aAAoB,UAA+B;AACjE,MAAM,mBAAmB,eAAe,QAAQ;AAChD,YACE,iBAAiB,cACjB,EAAA;MACE,eAAA,iBAAA,cAAA,MAAA,iBAAA;MACA,CAAA,aAAA,IAAA,GAAA,GAAA;AAGI,iBAAY,IAAU,KAAA,iBAAgB,OAAxB;EAEtB;MACE,UAAA,qBAAsB,oBAA0B,SAAA,aAAA;AACjD,WAAA,iBAAA,OAAA,SAAAC,UAAA;AAEK,uBAAU,aACd,IAAM,iBACJ,KAACA,QAAA;AACC,kBAAO;;sBAEM,CAAE,GAAC,WAAA;AAAA,WAAA,aAAA,IAAA,GAAA;EAAA,GAAA,WAAA;AAAA,WAAA,aAAA,IAAA,GAAA;EAAA,CAAA;MAChB,SAAG,MAAA,OAAA;AACL,SACC,gBAAiB,WAEpB;AAII,WAAM;MAEL,MAAM,OAAQ;MACnB,eAAO,OAAA;MACL,OAAM,cAAW,MAAA;;YAEjB,CAAA;;",
  "names": ["React", "React", "React", "React", "React", "React", "React", "DocumentType", "InternalState", "result", "eagerMethods", "key", "execute", "options", "React", "execute", "_a", "options", "mutation", "client", "React", "_a", "_b", "subscription", "result", "React", "React", "cache", "from", "React", "React", "React", "React", "realHook", "__use", "InternalQueryReference", "SuspenseCache", "promise", "promiseCache", "options", "variables", "_a", "React", "options", "promise", "promiseCache", "variables", "React", "promise"]
}
